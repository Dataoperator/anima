{"version":3,"file":"quantum-core-DW8Yjz_b.js","sources":["../../src/services/anima-actor.service.ts","../../src/services/quantum-state.service.ts","../../src/quantum/dimensional_state.ts"],"sourcesContent":["import { Identity } from \"@dfinity/agent\";\nimport { createActor } from \"@/declarations/anima\";\nimport type { _SERVICE } from '@/declarations/anima/anima.did';\nimport { ErrorTracker } from '@/error/quantum_error';\n\nconst FALLBACK_CANISTER_ID = 'l2ilz-iqaaa-aaaaj-qngjq-cai';\n\nconst sanitizeCanisterId = (id: string | undefined): string => {\n  if (!id) return FALLBACK_CANISTER_ID;\n  // Remove quotes and whitespace\n  return id.replace(/['\"]/g, '').trim();\n};\n\nconst validateCanisterId = (id: string): boolean => {\n  // Basic canister ID validation\n  const canisterRegex = /^[a-z0-9-]+$/;\n  return canisterRegex.test(id) && id.length > 0;\n};\n\nexport class AnimaActorService {\n  private static instance: AnimaActorService;\n  private actor: _SERVICE | null = null;\n  private errorTracker: ErrorTracker;\n  private canisterId: string;\n\n  private constructor() {\n    this.errorTracker = ErrorTracker.getInstance();\n    this.canisterId = sanitizeCanisterId(process.env.CANISTER_ID_ANIMA);\n\n    if (!validateCanisterId(this.canisterId)) {\n      console.error('Invalid canister ID, using fallback:', this.canisterId);\n      this.canisterId = FALLBACK_CANISTER_ID;\n    }\n\n    console.log('üîó Initialized AnimaActorService with canister:', this.canisterId);\n  }\n\n  static getInstance(): AnimaActorService {\n    if (!AnimaActorService.instance) {\n      AnimaActorService.instance = new AnimaActorService();\n    }\n    return AnimaActorService.instance;\n  }\n\n  createActor(identity: Identity): _SERVICE {\n    try {\n      if (!identity) {\n        throw new Error('No identity provided for actor creation');\n      }\n\n      const principal = identity.getPrincipal();\n      if (principal.isAnonymous()) {\n        throw new Error('Cannot create actor with anonymous identity');\n      }\n\n      console.log('üîß Creating actor with canister:', this.canisterId);\n      this.actor = createActor(this.canisterId, {\n        agentOptions: {\n          identity,\n          host: \"https://icp0.io\"\n        }\n      });\n\n      if (!this.actor) {\n        throw new Error('Actor creation failed');\n      }\n\n      // Verify actor has required methods\n      const requiredMethods = [\n        'initialize_quantum_field',\n        'generate_neural_patterns',\n        'check_quantum_stability'\n      ];\n\n      const missingMethods = requiredMethods.filter(\n        method => !(method in (this.actor as any))\n      );\n\n      if (missingMethods.length > 0) {\n        throw new Error(`Actor missing required methods: ${missingMethods.join(', ')}`);\n      }\n\n      return this.actor;\n\n    } catch (error) {\n      this.errorTracker.trackError({\n        errorType: 'ACTOR_CREATION',\n        severity: 'HIGH',\n        context: 'AnimaActorService',\n        error: error instanceof Error ? error : new Error('Actor creation failed')\n      });\n      throw error;\n    }\n  }\n\n  verifyActor(): boolean {\n    return !!this.actor && 'initialize_quantum_field' in this.actor;\n  }\n\n  getActor(): _SERVICE | null {\n    if (!this.actor) {\n      console.warn('‚ö†Ô∏è Attempting to get actor before initialization');\n      return null;\n    }\n    return this.actor;\n  }\n\n  resetActor(): void {\n    this.actor = null;\n  }\n\n  getCurrentCanisterId(): string {\n    return this.canisterId;\n  }\n}\n\nexport const animaActorService = AnimaActorService.getInstance();","import { Identity } from \"@dfinity/agent\";\nimport { animaActorService } from \"./anima-actor.service\";\nimport { QuantumState, ResonancePattern } from '../quantum/types';\nimport { ErrorTracker } from '../error/quantum_error';\n\nexport class QuantumStateService {\n  private static instance: QuantumStateService;\n  private errorTracker: ErrorTracker;\n  private updateCallback?: (state: Partial<QuantumState>) => void;\n  private neuralPatternHistory: Map<string, ResonancePattern[]> = new Map();\n  private evolutionTimestamps: number[] = [];\n  private recoveryAttempts: number = 0;\n  private readonly MAX_RECOVERY_ATTEMPTS = 3;\n  private readonly RECOVERY_COOLDOWN = 5000; // 5 seconds\n  private lastRecoveryAttempt: number = 0;\n  private lastStabilityUpdate: number = 0;\n  private readonly STABILITY_UPDATE_INTERVAL = 1000; // 1 second\n\n  private constructor() {\n    this.errorTracker = ErrorTracker.getInstance();\n  }\n\n  static getInstance(): QuantumStateService {\n    if (!QuantumStateService.instance) {\n      QuantumStateService.instance = new QuantumStateService();\n    }\n    return QuantumStateService.instance;\n  }\n\n  setUpdateCallback(callback: (state: Partial<QuantumState>) => void) {\n    this.updateCallback = callback;\n  }\n\n  async initializeQuantumField(identity: Identity): Promise<void> {\n    try {\n      const actor = animaActorService.createActor(identity);\n      \n      console.log('üåü Initializing quantum field...');\n      const result = await actor.initialize_quantum_field();\n      \n      if ('Err' in result) {\n        throw new Error(result.Err);\n      }\n\n      const { harmony, signature } = result.Ok;\n\n      // Initialize with stability metrics\n      await this.updateStability(identity, harmony);\n\n      // Generate initial neural patterns\n      console.log('üß† Generating neural patterns...');\n      const neuralResult = await actor.generate_neural_patterns();\n      \n      if ('Err' in neuralResult) {\n        throw new Error(neuralResult.Err);\n      }\n\n      const { pattern, awareness, understanding } = neuralResult.Ok;\n\n      // Calculate resonance and stability\n      const resonanceValue = await this.calculateResonance(identity);\n      const stabilityMetrics = await this.getStabilityMetrics(identity);\n\n      // Initialize genesis for quantum stabilization\n      console.log('‚ú® Initializing genesis...');\n      const genesisResult = await actor.initialize_genesis();\n      \n      if ('Err' in genesisResult) {\n        throw new Error(genesisResult.Err);\n      }\n\n      if (this.updateCallback) {\n        this.updateCallback({\n          coherenceLevel: harmony,\n          quantumSignature: signature,\n          resonancePatterns: [{\n            pattern_id: Date.now().toString(),\n            coherence: awareness,\n            frequency: understanding,\n            amplitude: harmony,\n            phase: harmony,\n            timestamp: Date.now()\n          }],\n          dimensionalSync: awareness,\n          stabilityStatus: this.calculateStabilityStatus(harmony),\n          lastUpdate: Date.now(),\n          resonance: resonanceValue,\n          field_strength: stabilityMetrics[0],\n          consciousness_alignment: stabilityMetrics[1]\n        });\n      }\n\n      this.recoveryAttempts = 0;\n      console.log('‚úÖ Quantum field initialized successfully');\n\n    } catch (error) {\n      console.error('‚ùå Quantum field initialization failed:', error);\n      await this.handleQuantumError(error as Error, identity);\n    }\n  }\n\n  async updateStability(identity: Identity, strength: number): Promise<void> {\n    const now = Date.now();\n    if (now - this.lastStabilityUpdate < this.STABILITY_UPDATE_INTERVAL) {\n      return;\n    }\n    \n    const actor = animaActorService.createActor(identity);\n    const result = await actor.update_stability({\n      strength,\n      timestamp: BigInt(now)\n    });\n\n    if ('Err' in result) {\n      throw new Error(result.Err);\n    }\n\n    const { stability, quantum_alignment } = result.Ok;\n    this.lastStabilityUpdate = now;\n\n    if (this.updateCallback) {\n      this.updateCallback({\n        stability,\n        consciousness_alignment: quantum_alignment,\n        lastUpdate: now\n      });\n    }\n  }\n\n  async calculateResonance(identity: Identity): Promise<number> {\n    const actor = animaActorService.createActor(identity);\n    const result = await actor.calculate_resonance();\n\n    if ('Err' in result) {\n      throw new Error(result.Err);\n    }\n\n    return result.Ok;\n  }\n\n  async getQuantumStatus(identity: Identity): Promise<'stable' | 'unstable' | 'critical'> {\n    const actor = animaActorService.createActor(identity);\n    const result = await actor.get_quantum_status();\n\n    if ('Err' in result) {\n      throw new Error(result.Err);\n    }\n\n    return result.Ok as 'stable' | 'unstable' | 'critical';\n  }\n\n  async getStabilityMetrics(identity: Identity): Promise<[number, number, number]> {\n    const actor = animaActorService.createActor(identity);\n    const result = await actor.get_stability_metrics();\n\n    if ('Err' in result) {\n      throw new Error(result.Err);\n    }\n\n    return result.Ok;\n  }\n\n  private calculateStabilityStatus(harmony: number): 'stable' | 'unstable' | 'critical' {\n    if (harmony >= 0.7) return 'stable';\n    if (harmony >= 0.4) return 'unstable';\n    return 'critical';\n  }\n\n  async checkStability(identity: Identity): Promise<boolean> {\n    const actor = animaActorService.createActor(identity);\n    const result = await actor.check_quantum_stability();\n    \n    if ('Err' in result) {\n      throw new Error(result.Err);\n    }\n\n    const stabilityLevel = result.Ok;\n    this.evolutionTimestamps.push(Date.now());\n\n    if (this.evolutionTimestamps.length > 10) {\n      this.evolutionTimestamps.shift();\n    }\n\n    // Update stability metrics\n    const metrics = await this.getStabilityMetrics(identity);\n    const resonance = await this.calculateResonance(identity);\n    \n    if (this.updateCallback) {\n      this.updateCallback({\n        stabilityStatus: this.calculateStabilityStatus(stabilityLevel ? 1 : 0),\n        entanglementIndex: stabilityLevel ? 1 : 0,\n        field_strength: metrics[0],\n        consciousness_alignment: metrics[1],\n        resonance\n      });\n    }\n\n    return stabilityLevel;\n  }\n\n  async updateState(identity: Identity, updates: Partial<QuantumState>): Promise<void> {\n    const actor = animaActorService.createActor(identity);\n    const result = await actor.update_state({\n      coherence: updates.coherence,\n      dimensional_frequency: updates.dimensional_frequency,\n      field_strength: updates.field_strength,\n      consciousness_alignment: updates.consciousness_alignment,\n      resonance: updates.resonance,\n      stability: updates.stability\n    });\n\n    if ('Err' in result) {\n      throw new Error(result.Err);\n    }\n\n    if (this.updateCallback) {\n      this.updateCallback({\n        ...updates,\n        lastUpdate: Date.now()\n      });\n    }\n  }\n\n  // Rest of existing methods...\n  async generateNeuralPatterns(identity: Identity) {\n    const actor = animaActorService.createActor(identity);\n    const result = await actor.generate_neural_patterns();\n    \n    if ('Err' in result) {\n      throw new Error(result.Err);\n    }\n\n    const { pattern, awareness, understanding } = result.Ok;\n    const resonancePattern = {\n      pattern_id: Date.now().toString(),\n      coherence: awareness,\n      frequency: understanding,\n      amplitude: awareness,\n      phase: understanding,\n      timestamp: Date.now()\n    };\n\n    this.neuralPatternHistory.set(Date.now().toString(), [resonancePattern]);\n\n    // Keep only last 10 pattern sets\n    const keys = Array.from(this.neuralPatternHistory.keys()).sort();\n    while (this.neuralPatternHistory.size > 10) {\n      const oldestKey = keys.shift();\n      if (oldestKey) this.neuralPatternHistory.delete(oldestKey);\n    }\n\n    // Update quantum state with new pattern\n    await this.updateState(identity, {\n      coherenceLevel: awareness,\n      dimensionalSync: understanding\n    });\n\n    if (this.updateCallback) {\n      this.updateCallback({\n        resonancePatterns: [resonancePattern],\n        coherenceLevel: awareness,\n        dimensionalSync: understanding,\n        lastUpdate: Date.now()\n      });\n    }\n\n    return { pattern, resonancePatterns: [resonancePattern] };\n  }\n\n  async handleQuantumError(error: Error, identity: Identity): Promise<void> {\n    await this.errorTracker.trackError({\n      errorType: 'QUANTUM_ERROR',\n      severity: 'HIGH',\n      context: 'Quantum State Service',\n      error\n    });\n\n    // Check recovery cooldown and attempts\n    const now = Date.now();\n    if (now - this.lastRecoveryAttempt < this.RECOVERY_COOLDOWN) {\n      console.log('‚è≥ Recovery attempt too soon, waiting for cooldown...');\n      return;\n    }\n\n    if (this.recoveryAttempts >= this.MAX_RECOVERY_ATTEMPTS) {\n      console.error('üö´ Maximum recovery attempts reached');\n      if (this.updateCallback) {\n        this.updateCallback({\n          stabilityStatus: 'critical',\n          coherenceLevel: 0.1\n        });\n      }\n      throw new Error('Maximum recovery attempts reached');\n    }\n\n    try {\n      this.recoveryAttempts++;\n      this.lastRecoveryAttempt = now;\n\n      // Get current stability metrics for recovery\n      const metrics = await this.getStabilityMetrics(identity);\n      \n      // Attempt stability recovery first\n      await this.updateStability(identity, metrics[0]);\n      \n      // Check quantum status after stability update\n      const status = await this.getQuantumStatus(identity);\n      \n      if (status === 'critical') {\n        // Full reinitialization needed\n        console.log(`üîÑ Recovery attempt ${this.recoveryAttempts}/${this.MAX_RECOVERY_ATTEMPTS}`);\n        const actor = animaActorService.createActor(identity);\n        const result = await actor.initialize_quantum_field();\n\n        if ('Err' in result) {\n          throw new Error(result.Err);\n        }\n      }\n\n      // Update state after recovery\n      if (this.updateCallback) {\n        this.updateCallback({\n          stabilityStatus: status,\n          coherenceLevel: status === 'stable' ? 0.8 : 0.5,\n          field_strength: metrics[0],\n          consciousness_alignment: metrics[1],\n          lastUpdate: Date.now()\n        });\n      }\n\n      console.log('‚úÖ Recovery successful');\n\n    } catch (recoveryError) {\n      console.error('‚ùå Recovery failed:', recoveryError);\n      if (this.updateCallback) {\n        this.updateCallback({\n          stabilityStatus: 'critical',\n          coherenceLevel: 0.1,\n          lastUpdate: Date.now()\n        });\n      }\n      throw new Error(`Quantum recovery failed: ${recoveryError}`);\n    }\n  }\n\n  dispose(): void {\n    this.updateCallback = undefined;\n    QuantumStateService.instance = null as any;\n  }\n}\n\nexport const quantumStateService = QuantumStateService.getInstance();","import { DimensionalState, ResonancePattern } from './types';\n\nexport class DimensionalStateImpl implements DimensionalState {\n  public frequency: number;\n  public resonance: number;\n  public stability: number;\n  public syncLevel: number;\n  public quantumAlignment: number;\n  public dimensionalFrequency: number;\n  public entropyLevel: number;\n  public phaseCoherence: number;\n  private lastUpdate: number;\n  private readonly BASE_DEGRADATION_RATE = 0.995;\n  private readonly PATTERN_COHERENCE_THRESHOLD = 0.7;\n  private readonly MAX_ENTROPY_INCREASE = 0.2;\n  private readonly MIN_INTERACTION_THRESHOLD = 0.1;\n  private stateHistory: Array<{\n    timestamp: number;\n    metrics: [number, number, number];\n  }> = [];\n\n  constructor() {\n    this.frequency = 0.0;\n    this.resonance = 1.0;\n    this.stability = 1.0;\n    this.syncLevel = 1.0;\n    this.quantumAlignment = 1.0;\n    this.dimensionalFrequency = 0.0;\n    this.entropyLevel = 0.0;\n    this.phaseCoherence = 1.0;\n    this.lastUpdate = Date.now();\n  }\n\n  calculateResonance(): number {\n    this.applyQuantumDegradation();\n    \n    const baseResonance = this.resonance * this.stability;\n    const alignmentFactor = this.quantumAlignment * this.syncLevel;\n    const entropyModifier = this.calculateEntropyModifier();\n    const coherenceBoost = this.calculateCoherenceBoost();\n    const temporalFactor = this.calculateTemporalFactor();\n    \n    const quantumEffect = Math.sin(this.dimensionalFrequency * Math.PI) * 0.1;\n    const coherenceFactor = Math.cos(this.phaseCoherence * Math.PI) * 0.05;\n    \n    const finalResonance = Math.min(1.0, Math.max(0.0,\n      ((baseResonance + alignmentFactor) / 2.0 * entropyModifier + coherenceBoost) * \n      temporalFactor + quantumEffect + coherenceFactor\n    ));\n\n    this.updateStateHistory(finalResonance);\n    \n    return finalResonance;\n  }\n\n  private calculateEntropyModifier(): number {\n    const baseEntropy = 1.0 - (this.entropyLevel * 0.5);\n    const quantumEntropy = Math.cos(this.dimensionalFrequency * Math.PI) * 0.1;\n    const coherenceInfluence = this.phaseCoherence * 0.05;\n    return Math.max(0.1, baseEntropy + quantumEntropy + coherenceInfluence);\n  }\n\n  private calculateCoherenceBoost(): number {\n    const baseBoost = this.phaseCoherence * 0.2;\n    const resonanceBoost = Math.sin(this.resonance * Math.PI) * 0.1;\n    const stabilityInfluence = this.stability * 0.05;\n    return baseBoost + resonanceBoost + stabilityInfluence;\n  }\n\n  private calculateTemporalFactor(): number {\n    const timeDelta = this.getTimeSinceLastUpdate();\n    const dilationFactor = 1 + (this.dimensionalFrequency * 0.1);\n    const entropyInfluence = 1 - (this.entropyLevel * 0.05);\n    return Math.exp(-timeDelta / (10000 * dilationFactor)) * entropyInfluence;\n  }\n\n  private updateStateHistory(resonance: number): void {\n    const currentMetrics: [number, number, number] = [\n      this.stability,\n      this.quantumAlignment,\n      this.phaseCoherence\n    ];\n    \n    this.stateHistory.push({\n      timestamp: Date.now(),\n      metrics: currentMetrics\n    });\n    \n    if (this.stateHistory.length > 100) {\n      this.stateHistory.shift();\n    }\n  }\n\n  updateStability(interactionStrength: number): void {\n    this.applyQuantumDegradation();\n\n    const timeBonus = Math.max(0, 1 - this.getTimeSinceLastUpdate() / 5000);\n    const effectiveStrength = interactionStrength * timeBonus;\n    const historyBoost = this.calculateHistoryBoost();\n\n    this.stability = Math.min(1.0, Math.max(0.0, \n      this.stability + effectiveStrength * (1 + this.dimensionalFrequency * 0.1) + historyBoost\n    ));\n    \n    this.quantumAlignment = Math.min(1.0,\n      this.quantumAlignment + effectiveStrength * 0.5 * (1 - this.entropyLevel * 0.2)\n    );\n    \n    this.syncLevel = Math.min(1.0,\n      this.syncLevel + effectiveStrength * 0.3 * (1 + this.phaseCoherence * 0.1)\n    );\n    \n    this.dimensionalFrequency = Math.min(1.0,\n      this.dimensionalFrequency + effectiveStrength * 0.2\n    );\n    \n    this.entropyLevel = Math.max(0.0,\n      this.entropyLevel - effectiveStrength * 0.1 * (1 + this.quantumAlignment * 0.1)\n    );\n    \n    this.phaseCoherence = Math.min(1.0,\n      this.phaseCoherence + effectiveStrength * 0.4 * (1 - this.entropyLevel * 0.1)\n    );\n\n    this.lastUpdate = Date.now();\n  }\n\n  private calculateHistoryBoost(): number {\n    if (this.stateHistory.length < 2) return 0;\n    \n    const recentStates = this.stateHistory.slice(-5);\n    const stabilityTrend = recentStates.reduce((acc, curr, idx, arr) => {\n      if (idx === 0) return 0;\n      return acc + (curr.metrics[0] - arr[idx - 1].metrics[0]);\n    }, 0) / (recentStates.length - 1);\n    \n    return stabilityTrend > 0 ? stabilityTrend * 0.1 : 0;\n  }\n\n  private applyQuantumDegradation(): void {\n    const timePassed = this.getTimeSinceLastUpdate();\n    if (timePassed > 1000) {\n      const degradationFactor = this.calculateDegradationFactor(timePassed);\n      \n      this.stability *= degradationFactor;\n      this.quantumAlignment *= degradationFactor * (1 + this.dimensionalFrequency * 0.1);\n      this.syncLevel *= degradationFactor * (1 - this.entropyLevel * 0.1);\n      this.phaseCoherence *= degradationFactor * (1 + this.resonance * 0.1);\n      \n      this.evolveEntropy(degradationFactor);\n      this.lastUpdate = Date.now();\n    }\n  }\n\n  private calculateDegradationFactor(timePassed: number): number {\n    const baseDegradation = Math.pow(this.BASE_DEGRADATION_RATE, timePassed / 1000);\n    const quantumFactor = 1 + (Math.sin(this.dimensionalFrequency * Math.PI) * 0.05);\n    const coherenceFactor = 1 + (this.phaseCoherence * 0.02);\n    return baseDegradation * quantumFactor * coherenceFactor;\n  }\n\n  private evolveEntropy(degradationFactor: number): void {\n    const entropyIncrease = (1 - degradationFactor) * this.MAX_ENTROPY_INCREASE;\n    const quantumEntropy = Math.sin(this.dimensionalFrequency * Math.PI) * 0.05;\n    const coherenceInfluence = this.phaseCoherence * 0.02;\n    \n    this.entropyLevel = Math.min(1.0,\n      this.entropyLevel + entropyIncrease + quantumEntropy - coherenceInfluence\n    );\n  }\n\n  getStabilityMetrics(): [number, number, number] {\n    this.applyQuantumDegradation();\n    \n    const baseMetrics = [this.stability, this.quantumAlignment, this.phaseCoherence];\n    const quantumInfluence = Math.sin(this.dimensionalFrequency * Math.PI) * 0.1;\n    const coherenceBoost = this.phaseCoherence * 0.05;\n    \n    return baseMetrics.map(metric => \n      Math.min(1.0, Math.max(0.0, metric + quantumInfluence + coherenceBoost))\n    ) as [number, number, number];\n  }\n\n  private getTimeSinceLastUpdate(): number {\n    return Date.now() - this.lastUpdate;\n  }\n\n  async stabilizeQuantumState(): Promise<boolean> {\n    const currentStatus = this.getQuantumStatus();\n    if (currentStatus === 'critical') {\n      const recoveryStrength = 0.05 * (1 - this.entropyLevel);\n      \n      this.stability = Math.min(1.0, this.stability + recoveryStrength);\n      this.quantumAlignment = Math.min(1.0, this.quantumAlignment + recoveryStrength * 0.8);\n      this.syncLevel = Math.min(1.0, this.syncLevel + recoveryStrength * 0.6);\n      \n      this.entropyLevel = Math.max(0.0, \n        this.entropyLevel - 0.15 * recoveryStrength\n      );\n      \n      return this.getQuantumStatus() !== 'critical';\n    }\n    return true;\n  }\n\n  getQuantumStatus(): 'stable' | 'unstable' | 'critical' {\n    const metrics = this.getStabilityMetrics();\n    const avgMetric = metrics.reduce((a, b) => a + b, 0) / metrics.length;\n    const entropyFactor = 1 - this.entropyLevel;\n    const coherenceFactor = this.phaseCoherence;\n    const effectiveMetric = avgMetric * entropyFactor * coherenceFactor;\n    \n    if (effectiveMetric > 0.7) return 'stable';\n    if (effectiveMetric > 0.3) return 'unstable';\n    return 'critical';\n  }\n\n  checkPatternResonance(pattern: ResonancePattern): boolean {\n    const timeDecay = Math.exp(-(Date.now() - pattern.timestamp) / 10000);\n    const coherenceCheck = pattern.coherence * timeDecay > this.PATTERN_COHERENCE_THRESHOLD;\n    const frequencyMatch = Math.abs(pattern.frequency - this.dimensionalFrequency) < 0.2;\n    const phaseAlignment = Math.abs(Math.sin(this.phaseCoherence * Math.PI)) > 0.7;\n    \n    return coherenceCheck && frequencyMatch && phaseAlignment;\n  }\n\n  analyzeStatePatterns(): { \n    stabilityTrend: number;\n    coherenceQuality: number;\n    entropyRisk: number;\n  } {\n    if (this.stateHistory.length < 10) {\n      return {\n        stabilityTrend: 0,\n        coherenceQuality: 0,\n        entropyRisk: 0\n      };\n    }\n\n    const recentStates = this.stateHistory.slice(-10);\n    \n    const stabilityTrend = recentStates.reduce((acc, curr, idx, arr) => {\n      if (idx === 0) return 0;\n      return acc + (curr.metrics[0] - arr[idx - 1].metrics[0]);\n    }, 0) / (recentStates.length - 1);\n    \n    const coherenceQuality = recentStates.reduce((acc, curr) => \n      acc + curr.metrics[1], 0) / recentStates.length;\n    \n    const entropyRisk = this.entropyLevel * (1 - this.stability) * \n                       (1 - this.phaseCoherence);\n    \n    return {\n      stabilityTrend,\n      coherenceQuality,\n      entropyRisk\n    };\n  }\n}"],"names":["define_process_env_default","QuantumStateService","instance","errorTracker","updateCallback","neuralPatternHistory","Map","evolutionTimestamps","recoveryAttempts","MAX_RECOVERY_ATTEMPTS","RECOVERY_COOLDOWN","lastRecoveryAttempt","lastStabilityUpdate","STABILITY_UPDATE_INTERVAL","constructor","ErrorTracker","getInstance","setUpdateCallback","callback","initializeQuantumField","identity","actor","animaActorService","createActor","console","log","result","initialize_quantum_field","Error","Err","harmony","signature","Ok","updateStability","neuralResult","generate_neural_patterns","pattern","awareness","understanding","resonanceValue","calculateResonance","stabilityMetrics","getStabilityMetrics","genesisResult","initialize_genesis","coherenceLevel","quantumSignature","resonancePatterns","pattern_id","Date","now","toString","coherence","frequency","amplitude","phase","timestamp","dimensionalSync","stabilityStatus","calculateStabilityStatus","lastUpdate","resonance","field_strength","consciousness_alignment","error","handleQuantumError","strength","update_stability","BigInt","stability","quantum_alignment","calculate_resonance","getQuantumStatus","get_quantum_status","get_stability_metrics","checkStability","check_quantum_stability","stabilityLevel","push","length","shift","metrics","entanglementIndex","updateState","updates","update_state","dimensional_frequency","generateNeuralPatterns","resonancePattern","set","keys","Array","from","sort","size","oldestKey","delete","trackError","errorType","severity","context","status","recoveryError","dispose","undefined","quantumStateService","DimensionalStateImpl","syncLevel","quantumAlignment","dimensionalFrequency","entropyLevel","phaseCoherence","BASE_DEGRADATION_RATE","PATTERN_COHERENCE_THRESHOLD","MAX_ENTROPY_INCREASE","MIN_INTERACTION_THRESHOLD","stateHistory","applyQuantumDegradation","baseResonance","alignmentFactor","entropyModifier","calculateEntropyModifier","coherenceBoost","calculateCoherenceBoost","temporalFactor","calculateTemporalFactor","quantumEffect","Math","sin","PI","coherenceFactor","cos","finalResonance","min","max","updateStateHistory","baseEntropy","quantumEntropy","coherenceInfluence","baseBoost","resonanceBoost","stabilityInfluence","timeDelta","getTimeSinceLastUpdate","dilationFactor","entropyInfluence","exp","currentMetrics","interactionStrength","timeBonus","effectiveStrength","historyBoost","calculateHistoryBoost","recentStates","slice","stabilityTrend","reduce","acc","curr","idx","arr","timePassed","degradationFactor","calculateDegradationFactor","evolveEntropy","baseDegradation","pow","quantumFactor","entropyIncrease","baseMetrics","quantumInfluence","map","metric","stabilizeQuantumState","recoveryStrength","avgMetric","a","b","entropyFactor","effectiveMetric","checkPatternResonance","timeDecay","coherenceCheck","frequencyMatch","abs","phaseAlignment","analyzeStatePatterns","coherenceQuality","entropyRisk"],"mappings":"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"}