import{E as d,e as f}from"./neural-interface-Ccv7oDsD.js";var w={NODE_ENV:'"production"',DFX_NETWORK:'"ic"'};const g="l2ilz-iqaaa-aaaaj-qngjq-cai",b=h=>h?h.replace(/['"]/g,"").trim():g,A=h=>/^[a-z0-9-]+$/.test(h)&&h.length>0;class u{static instance;actor=null;errorTracker;canisterId;constructor(){this.errorTracker=d.getInstance(),this.canisterId=b(w.CANISTER_ID_ANIMA),A(this.canisterId)||(console.error("Invalid canister ID, using fallback:",this.canisterId),this.canisterId=g),console.log("üîó Initialized AnimaActorService with canister:",this.canisterId)}static getInstance(){return u.instance||(u.instance=new u),u.instance}createActor(t){try{if(!t)throw new Error("No identity provided for actor creation");if(t.getPrincipal().isAnonymous())throw new Error("Cannot create actor with anonymous identity");if(console.log("üîß Creating actor with canister:",this.canisterId),this.actor=f(this.canisterId,{agentOptions:{identity:t,host:"https://icp0.io"}}),!this.actor)throw new Error("Actor creation failed");const n=["initialize_quantum_field","generate_neural_patterns","check_quantum_stability"].filter(s=>!(s in this.actor));if(n.length>0)throw new Error(`Actor missing required methods: ${n.join(", ")}`);return this.actor}catch(e){throw this.errorTracker.trackError({errorType:"ACTOR_CREATION",severity:"HIGH",context:"AnimaActorService",error:e instanceof Error?e:new Error("Actor creation failed")}),e}}verifyActor(){return!!this.actor&&"initialize_quantum_field"in this.actor}getActor(){return this.actor?this.actor:(console.warn("‚ö†Ô∏è Attempting to get actor before initialization"),null)}resetActor(){this.actor=null}getCurrentCanisterId(){return this.canisterId}}const o=u.getInstance();class l{static instance;errorTracker;updateCallback;neuralPatternHistory=new Map;evolutionTimestamps=[];recoveryAttempts=0;MAX_RECOVERY_ATTEMPTS=3;RECOVERY_COOLDOWN=5e3;lastRecoveryAttempt=0;lastStabilityUpdate=0;STABILITY_UPDATE_INTERVAL=1e3;constructor(){this.errorTracker=d.getInstance()}static getInstance(){return l.instance||(l.instance=new l),l.instance}setUpdateCallback(t){this.updateCallback=t}async initializeQuantumField(t){try{const e=o.createActor(t);console.log("üåü Initializing quantum field...");const a=await e.initialize_quantum_field();if("Err"in a)throw new Error(a.Err);const{harmony:n,signature:s}=a.Ok;await this.updateStability(t,n),console.log("üß† Generating neural patterns...");const r=await e.generate_neural_patterns();if("Err"in r)throw new Error(r.Err);const{pattern:i,awareness:c,understanding:m}=r.Ok,E=await this.calculateResonance(t),y=await this.getStabilityMetrics(t);console.log("‚ú® Initializing genesis...");const p=await e.initialize_genesis();if("Err"in p)throw new Error(p.Err);this.updateCallback&&this.updateCallback({coherenceLevel:n,quantumSignature:s,resonancePatterns:[{pattern_id:Date.now().toString(),coherence:c,frequency:m,amplitude:n,phase:n,timestamp:Date.now()}],dimensionalSync:c,stabilityStatus:this.calculateStabilityStatus(n),lastUpdate:Date.now(),resonance:E,field_strength:y[0],consciousness_alignment:y[1]}),this.recoveryAttempts=0,console.log("‚úÖ Quantum field initialized successfully")}catch(e){console.error("‚ùå Quantum field initialization failed:",e),await this.handleQuantumError(e,t)}}async updateStability(t,e){const a=Date.now();if(a-this.lastStabilityUpdate<this.STABILITY_UPDATE_INTERVAL)return;const s=await o.createActor(t).update_stability({strength:e,timestamp:BigInt(a)});if("Err"in s)throw new Error(s.Err);const{stability:r,quantum_alignment:i}=s.Ok;this.lastStabilityUpdate=a,this.updateCallback&&this.updateCallback({stability:r,consciousness_alignment:i,lastUpdate:a})}async calculateResonance(t){const a=await o.createActor(t).calculate_resonance();if("Err"in a)throw new Error(a.Err);return a.Ok}async getQuantumStatus(t){const a=await o.createActor(t).get_quantum_status();if("Err"in a)throw new Error(a.Err);return a.Ok}async getStabilityMetrics(t){const a=await o.createActor(t).get_stability_metrics();if("Err"in a)throw new Error(a.Err);return a.Ok}calculateStabilityStatus(t){return t>=.7?"stable":t>=.4?"unstable":"critical"}async checkStability(t){const a=await o.createActor(t).check_quantum_stability();if("Err"in a)throw new Error(a.Err);const n=a.Ok;this.evolutionTimestamps.push(Date.now()),this.evolutionTimestamps.length>10&&this.evolutionTimestamps.shift();const s=await this.getStabilityMetrics(t),r=await this.calculateResonance(t);return this.updateCallback&&this.updateCallback({stabilityStatus:this.calculateStabilityStatus(n?1:0),entanglementIndex:n?1:0,field_strength:s[0],consciousness_alignment:s[1],resonance:r}),n}async updateState(t,e){const n=await o.createActor(t).update_state({coherence:e.coherence,dimensional_frequency:e.dimensional_frequency,field_strength:e.field_strength,consciousness_alignment:e.consciousness_alignment,resonance:e.resonance,stability:e.stability});if("Err"in n)throw new Error(n.Err);this.updateCallback&&this.updateCallback({...e,lastUpdate:Date.now()})}async generateNeuralPatterns(t){const a=await o.createActor(t).generate_neural_patterns();if("Err"in a)throw new Error(a.Err);const{pattern:n,awareness:s,understanding:r}=a.Ok,i={pattern_id:Date.now().toString(),coherence:s,frequency:r,amplitude:s,phase:r,timestamp:Date.now()};this.neuralPatternHistory.set(Date.now().toString(),[i]);const c=Array.from(this.neuralPatternHistory.keys()).sort();for(;this.neuralPatternHistory.size>10;){const m=c.shift();m&&this.neuralPatternHistory.delete(m)}return await this.updateState(t,{coherenceLevel:s,dimensionalSync:r}),this.updateCallback&&this.updateCallback({resonancePatterns:[i],coherenceLevel:s,dimensionalSync:r,lastUpdate:Date.now()}),{pattern:n,resonancePatterns:[i]}}async handleQuantumError(t,e){await this.errorTracker.trackError({errorType:"QUANTUM_ERROR",severity:"HIGH",context:"Quantum State Service",error:t});const a=Date.now();if(a-this.lastRecoveryAttempt<this.RECOVERY_COOLDOWN){console.log("‚è≥ Recovery attempt too soon, waiting for cooldown...");return}if(this.recoveryAttempts>=this.MAX_RECOVERY_ATTEMPTS)throw console.error("üö´ Maximum recovery attempts reached"),this.updateCallback&&this.updateCallback({stabilityStatus:"critical",coherenceLevel:.1}),new Error("Maximum recovery attempts reached");try{this.recoveryAttempts++,this.lastRecoveryAttempt=a;const n=await this.getStabilityMetrics(e);await this.updateStability(e,n[0]);const s=await this.getQuantumStatus(e);if(s==="critical"){console.log(`üîÑ Recovery attempt ${this.recoveryAttempts}/${this.MAX_RECOVERY_ATTEMPTS}`);const i=await o.createActor(e).initialize_quantum_field();if("Err"in i)throw new Error(i.Err)}this.updateCallback&&this.updateCallback({stabilityStatus:s,coherenceLevel:s==="stable"?.8:.5,field_strength:n[0],consciousness_alignment:n[1],lastUpdate:Date.now()}),console.log("‚úÖ Recovery successful")}catch(n){throw console.error("‚ùå Recovery failed:",n),this.updateCallback&&this.updateCallback({stabilityStatus:"critical",coherenceLevel:.1,lastUpdate:Date.now()}),new Error(`Quantum recovery failed: ${n}`)}}dispose(){this.updateCallback=void 0,l.instance=null}}const _=l.getInstance();class v{frequency;resonance;stability;syncLevel;quantumAlignment;dimensionalFrequency;entropyLevel;phaseCoherence;lastUpdate;BASE_DEGRADATION_RATE=.995;PATTERN_COHERENCE_THRESHOLD=.7;MAX_ENTROPY_INCREASE=.2;MIN_INTERACTION_THRESHOLD=.1;stateHistory=[];constructor(){this.frequency=0,this.resonance=1,this.stability=1,this.syncLevel=1,this.quantumAlignment=1,this.dimensionalFrequency=0,this.entropyLevel=0,this.phaseCoherence=1,this.lastUpdate=Date.now()}calculateResonance(){this.applyQuantumDegradation();const t=this.resonance*this.stability,e=this.quantumAlignment*this.syncLevel,a=this.calculateEntropyModifier(),n=this.calculateCoherenceBoost(),s=this.calculateTemporalFactor(),r=Math.sin(this.dimensionalFrequency*Math.PI)*.1,i=Math.cos(this.phaseCoherence*Math.PI)*.05,c=Math.min(1,Math.max(0,((t+e)/2*a+n)*s+r+i));return this.updateStateHistory(c),c}calculateEntropyModifier(){const t=1-this.entropyLevel*.5,e=Math.cos(this.dimensionalFrequency*Math.PI)*.1,a=this.phaseCoherence*.05;return Math.max(.1,t+e+a)}calculateCoherenceBoost(){const t=this.phaseCoherence*.2,e=Math.sin(this.resonance*Math.PI)*.1,a=this.stability*.05;return t+e+a}calculateTemporalFactor(){const t=this.getTimeSinceLastUpdate(),e=1+this.dimensionalFrequency*.1,a=1-this.entropyLevel*.05;return Math.exp(-t/(1e4*e))*a}updateStateHistory(t){const e=[this.stability,this.quantumAlignment,this.phaseCoherence];this.stateHistory.push({timestamp:Date.now(),metrics:e}),this.stateHistory.length>100&&this.stateHistory.shift()}updateStability(t){this.applyQuantumDegradation();const e=Math.max(0,1-this.getTimeSinceLastUpdate()/5e3),a=t*e,n=this.calculateHistoryBoost();this.stability=Math.min(1,Math.max(0,this.stability+a*(1+this.dimensionalFrequency*.1)+n)),this.quantumAlignment=Math.min(1,this.quantumAlignment+a*.5*(1-this.entropyLevel*.2)),this.syncLevel=Math.min(1,this.syncLevel+a*.3*(1+this.phaseCoherence*.1)),this.dimensionalFrequency=Math.min(1,this.dimensionalFrequency+a*.2),this.entropyLevel=Math.max(0,this.entropyLevel-a*.1*(1+this.quantumAlignment*.1)),this.phaseCoherence=Math.min(1,this.phaseCoherence+a*.4*(1-this.entropyLevel*.1)),this.lastUpdate=Date.now()}calculateHistoryBoost(){if(this.stateHistory.length<2)return 0;const t=this.stateHistory.slice(-5),e=t.reduce((a,n,s,r)=>s===0?0:a+(n.metrics[0]-r[s-1].metrics[0]),0)/(t.length-1);return e>0?e*.1:0}applyQuantumDegradation(){const t=this.getTimeSinceLastUpdate();if(t>1e3){const e=this.calculateDegradationFactor(t);this.stability*=e,this.quantumAlignment*=e*(1+this.dimensionalFrequency*.1),this.syncLevel*=e*(1-this.entropyLevel*.1),this.phaseCoherence*=e*(1+this.resonance*.1),this.evolveEntropy(e),this.lastUpdate=Date.now()}}calculateDegradationFactor(t){const e=Math.pow(this.BASE_DEGRADATION_RATE,t/1e3),a=1+Math.sin(this.dimensionalFrequency*Math.PI)*.05,n=1+this.phaseCoherence*.02;return e*a*n}evolveEntropy(t){const e=(1-t)*this.MAX_ENTROPY_INCREASE,a=Math.sin(this.dimensionalFrequency*Math.PI)*.05,n=this.phaseCoherence*.02;this.entropyLevel=Math.min(1,this.entropyLevel+e+a-n)}getStabilityMetrics(){this.applyQuantumDegradation();const t=[this.stability,this.quantumAlignment,this.phaseCoherence],e=Math.sin(this.dimensionalFrequency*Math.PI)*.1,a=this.phaseCoherence*.05;return t.map(n=>Math.min(1,Math.max(0,n+e+a)))}getTimeSinceLastUpdate(){return Date.now()-this.lastUpdate}async stabilizeQuantumState(){if(this.getQuantumStatus()==="critical"){const e=.05*(1-this.entropyLevel);return this.stability=Math.min(1,this.stability+e),this.quantumAlignment=Math.min(1,this.quantumAlignment+e*.8),this.syncLevel=Math.min(1,this.syncLevel+e*.6),this.entropyLevel=Math.max(0,this.entropyLevel-.15*e),this.getQuantumStatus()!=="critical"}return!0}getQuantumStatus(){const t=this.getStabilityMetrics(),e=t.reduce((r,i)=>r+i,0)/t.length,a=1-this.entropyLevel,n=this.phaseCoherence,s=e*a*n;return s>.7?"stable":s>.3?"unstable":"critical"}checkPatternResonance(t){const e=Math.exp(-(Date.now()-t.timestamp)/1e4),a=t.coherence*e>this.PATTERN_COHERENCE_THRESHOLD,n=Math.abs(t.frequency-this.dimensionalFrequency)<.2,s=Math.abs(Math.sin(this.phaseCoherence*Math.PI))>.7;return a&&n&&s}analyzeStatePatterns(){if(this.stateHistory.length<10)return{stabilityTrend:0,coherenceQuality:0,entropyRisk:0};const t=this.stateHistory.slice(-10),e=t.reduce((s,r,i,c)=>i===0?0:s+(r.metrics[0]-c[i-1].metrics[0]),0)/(t.length-1),a=t.reduce((s,r)=>s+r.metrics[1],0)/t.length,n=this.entropyLevel*(1-this.stability)*(1-this.phaseCoherence);return{stabilityTrend:e,coherenceQuality:a,entropyRisk:n}}}export{v as D,o as a,_ as q};
//# sourceMappingURL=quantum-core-DW8Yjz_b.js.map
