{"version":3,"file":"quantum.worker-BMZTCHt-.js","sources":["../src/workers/quantum.worker.ts"],"sourcesContent":["import { QuantumState, ResonancePattern } from '../quantum/types';\n\nconst calculateCoherence = (patterns: ResonancePattern[]): number => {\n  if (!patterns.length) return 0;\n  \n  const coherenceValues = patterns.map(p => p.coherence);\n  const weightedSum = coherenceValues.reduce((sum, val, i) => {\n    const weight = Math.exp(-0.1 * (patterns.length - 1 - i));\n    return sum + val * weight;\n  }, 0);\n  \n  const weightSum = coherenceValues.length ? \n    Array(coherenceValues.length).fill(0)\n      .reduce((sum, _, i) => sum + Math.exp(-0.1 * i), 0) : 1;\n  \n  return weightedSum / weightSum;\n};\n\nconst generateResonancePattern = (\n  previousPatterns: ResonancePattern[],\n  baseCoherence: number\n): ResonancePattern => {\n  const now = Date.now();\n  const prevPattern = previousPatterns[previousPatterns.length - 1];\n  \n  const coherenceShift = (Math.random() - 0.5) * 0.1;\n  const frequencyShift = (Math.random() - 0.5) * 0.1;\n  const phaseShift = (Math.random() - 0.5) * 0.1;\n  \n  return {\n    pattern_id: `p-${now}`,\n    coherence: Math.max(0, Math.min(1, baseCoherence + coherenceShift)),\n    frequency: prevPattern ? \n      Math.max(0, Math.min(1, prevPattern.frequency + frequencyShift)) : \n      0.5 + frequencyShift,\n    amplitude: Math.random() * 0.5 + 0.5,\n    phase: prevPattern ? \n      Math.max(0, Math.min(1, prevPattern.phase + phaseShift)) : \n      0.5 + phaseShift,\n    timestamp: now,\n    entropyLevel: Math.random() * 0.3,\n    stabilityIndex: Math.random() * 0.7 + 0.3,\n    quantumSignature: `QS-${now}-${Math.random().toString(36).substring(7)}`,\n    evolutionPotential: Math.random() * 0.5 + 0.5,\n    coherenceQuality: Math.random() * 0.3 + 0.7,\n    temporalStability: Math.random() * 0.2 + 0.8,\n    dimensionalAlignment: Math.random() * 0.2 + 0.8\n  };\n};\n\nconst calculateDimensionalResonance = (patterns: ResonancePattern[]): number => {\n  if (!patterns.length) return 0;\n  \n  const alignmentValues = patterns.map(p => p.dimensionalAlignment);\n  const stabilityValues = patterns.map(p => p.stabilityIndex);\n  \n  const alignmentScore = alignmentValues.reduce((sum, val) => sum + val, 0) / alignmentValues.length;\n  const stabilityScore = stabilityValues.reduce((sum, val) => sum + val, 0) / stabilityValues.length;\n  \n  return (alignmentScore * 0.7 + stabilityScore * 0.3);\n};\n\nconst calculateEvolutionMetrics = (\n  patterns: ResonancePattern[],\n  currentState: QuantumState\n): Map<string, number> => {\n  const metrics = new Map<string, number>();\n  \n  // Calculate base metrics\n  metrics.set('coherenceGrowth', \n    patterns.length > 1 ? \n      (patterns[patterns.length - 1].coherence - patterns[0].coherence) / patterns.length : \n      0\n  );\n  \n  metrics.set('stabilityTrend',\n    patterns.reduce((acc, p) => acc + p.stabilityIndex, 0) / patterns.length\n  );\n  \n  metrics.set('dimensionalHarmony',\n    patterns.reduce((acc, p) => acc + p.dimensionalAlignment, 0) / patterns.length\n  );\n  \n  // Calculate advanced metrics\n  metrics.set('evolutionVelocity', \n    Math.min(1, currentState.evolutionMetrics?.get('evolutionVelocity') || 0 + metrics.get('coherenceGrowth') || 0)\n  );\n  \n  metrics.set('consciousnessDepth',\n    (currentState.coherenceLevel + metrics.get('dimensionalHarmony') || 0) / 2\n  );\n  \n  return metrics;\n};\n\nconst handlers = {\n  calculateCoherence: (patterns: ResonancePattern[]) => ({\n    coherenceLevel: calculateCoherence(patterns)\n  }),\n  \n  generatePattern: (\n    previousPatterns: ResonancePattern[],\n    baseCoherence: number\n  ) => ({\n    pattern: generateResonancePattern(previousPatterns, baseCoherence)\n  }),\n  \n  updateQuantumState: (\n    currentState: QuantumState,\n    newPatterns: ResonancePattern[]\n  ) => {\n    const coherenceLevel = calculateCoherence(newPatterns);\n    const dimensionalResonance = calculateDimensionalResonance(newPatterns);\n    const evolutionMetrics = calculateEvolutionMetrics(newPatterns, currentState);\n    \n    return {\n      coherenceLevel,\n      dimensionalResonance,\n      evolutionMetrics,\n      patternCoherence: Math.min(coherenceLevel * 1.1, 1),\n      lastUpdate: Date.now()\n    };\n  }\n};\n\nself.onmessage = async (e: MessageEvent) => {\n  const { type, payload } = e.data;\n  \n  if (type in handlers) {\n    try {\n      const result = await handlers[type](payload);\n      self.postMessage({ type, result });\n    } catch (error) {\n      self.postMessage({ \n        type, \n        error: error instanceof Error ? error.message : 'Unknown error' \n      });\n    }\n  }\n};\n\nexport {};"],"names":["calculateCoherence","patterns","coherenceValues","p","weightedSum","sum","val","i","weight","weightSum","_","generateResonancePattern","previousPatterns","baseCoherence","now","prevPattern","coherenceShift","frequencyShift","phaseShift","calculateDimensionalResonance","alignmentValues","stabilityValues","alignmentScore","stabilityScore","calculateEvolutionMetrics","currentState","metrics","acc","handlers","newPatterns","coherenceLevel","dimensionalResonance","evolutionMetrics","type","payload","result","error"],"mappings":"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"}