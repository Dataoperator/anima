{"version":3,"file":"quantum-features-SpmCtDM2.js","sources":["../../src/declarations/anima/anima.did.js","../../src/declarations/anima/index.js","../../src/hooks/useIC.ts","../../src/contexts/auth-context.tsx","../../src/services/realtime.ts","../../src/types/realtime.ts","../../src/hooks/useRealtimePersonality.ts","../../src/hooks/useAnimaChat.js","../../src/hooks/useQuantumMemory.ts","../../src/components/quantum/QuantumField.jsx"],"sourcesContent":["export const idlFactory = ({ IDL }) => {\n  const Error = IDL.Text;\n  const TokenIdentifier = IDL.Nat64;\n  const NFTPersonality = IDL.Record({\n    'traits' : IDL.Vec(IDL.Tuple(IDL.Text, IDL.Float64)),\n    'emotional_state' : IDL.Record({\n      'duration' : IDL.Nat64,\n      'current_emotion' : IDL.Text,\n      'intensity' : IDL.Float64,\n    }),\n    'memories' : IDL.Vec(\n      IDL.Record({\n        'emotional_impact' : IDL.Float64,\n        'content' : IDL.Text,\n        'timestamp' : IDL.Nat64,\n      })\n    ),\n    'developmental_stage' : IDL.Variant({\n      'SelfAware' : IDL.Null,\n      'Awakening' : IDL.Null,\n      'Conscious' : IDL.Null,\n      'Transcendent' : IDL.Null,\n      'Nascent' : IDL.Null,\n    }),\n  });\n  const AnimaState = IDL.Record({\n    'id' : TokenIdentifier,\n    'creation_time' : IDL.Nat64,\n    'personality' : NFTPersonality,\n    'owner' : IDL.Principal,\n    'name' : IDL.Text,\n  });\n  const ConsciousnessLevel = IDL.Variant({\n    'SelfAware' : IDL.Null,\n    'Awakening' : IDL.Null,\n    'Introspective' : IDL.Null,\n    'Transcendent' : IDL.Null,\n    'Nascent' : IDL.Null,\n  });\n  const ActionResult = IDL.Variant({\n    'Success' : IDL.Record({\n      'personality_updates' : IDL.Vec(IDL.Tuple(IDL.Text, IDL.Float64)),\n      'response' : IDL.Text,\n    }),\n    'Failure' : Error,\n  });\n  return IDL.Service({\n    'create_anima' : IDL.Func(\n        [IDL.Text],\n        [IDL.Variant({ 'Ok' : IDL.Principal, 'Err' : Error })],\n        [],\n      ),\n    'get_anima' : IDL.Func([TokenIdentifier], [IDL.Opt(AnimaState)], ['query']),\n    'get_consciousness_level' : IDL.Func(\n        [TokenIdentifier],\n        [IDL.Variant({ 'Ok' : ConsciousnessLevel, 'Err' : Error })],\n        ['query'],\n      ),\n    'get_user_animas' : IDL.Func(\n        [IDL.Principal],\n        [IDL.Vec(AnimaState)],\n        ['query'],\n      ),\n    'process_quantum_interaction' : IDL.Func(\n        [TokenIdentifier, IDL.Text, IDL.Text],\n        [ActionResult],\n        [],\n      ),\n  });\n};\nexport const init = ({ IDL }) => { return []; };\n","import { Actor, HttpAgent } from \"@dfinity/agent\";\n\n// Imports and re-exports candid interface\nimport { idlFactory } from \"./anima.did.js\";\nexport { idlFactory } from \"./anima.did.js\";\n\n/* CANISTER_ID is replaced by webpack based on node environment\n * Note: canister environment variable will be standardized as\n * process.env.CANISTER_ID_<CANISTER_NAME_UPPERCASE>\n * beginning in dfx 0.15.0\n */\nexport const canisterId =\n  process.env.CANISTER_ID_ANIMA;\n\nexport const createActor = (canisterId, options = {}) => {\n  const agent = options.agent || new HttpAgent({ ...options.agentOptions });\n\n  if (options.agent && options.agentOptions) {\n    console.warn(\n      \"Detected both agent and agentOptions passed to createActor. Ignoring agentOptions and proceeding with the provided agent.\"\n    );\n  }\n\n  // Fetch root key for certificate validation during development\n  if (process.env.DFX_NETWORK !== \"ic\") {\n    agent.fetchRootKey().catch((err) => {\n      console.warn(\n        \"Unable to fetch root key. Check to ensure that your local replica is running\"\n      );\n      console.error(err);\n    });\n  }\n\n  // Creates an actor with using the candid interface and the HttpAgent\n  return Actor.createActor(idlFactory, {\n    agent,\n    canisterId,\n    ...options.actorOptions,\n  });\n};\n","import { useState, useEffect } from 'react';\nimport { Identity, HttpAgent } from \"@dfinity/agent\";\nimport { icManager } from '../ic-init';\nimport type { _SERVICE } from \"../declarations/anima/anima.did\";\n\ninterface ICHookResult {\n  actor: _SERVICE | null;\n  identity: Identity | null;\n  agent: HttpAgent | null;\n  isAuthenticated: boolean;\n  isAnonymous: boolean;\n  login: () => Promise<boolean>;\n  logout: () => Promise<void>;\n  error: Error | null;\n}\n\nexport function useIC(): ICHookResult {\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n  const [isAnonymous, setIsAnonymous] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n  const [actor, setActor] = useState<_SERVICE | null>(null);\n\n  useEffect(() => {\n    const initIC = async () => {\n      try {\n        if (!icManager.isInitialized()) {\n          await icManager.initialize();\n        }\n        \n        const identity = icManager.getIdentity();\n        const isAnon = identity?.getPrincipal().isAnonymous() ?? true;\n        \n        setIsAuthenticated(!isAnon);\n        setIsAnonymous(isAnon);\n        setActor(icManager.getActor<_SERVICE>());\n        setError(null);\n      } catch (err) {\n        setError(err as Error);\n        setIsAuthenticated(false);\n        setIsAnonymous(true);\n        setActor(null);\n      }\n    };\n\n    initIC();\n  }, []);\n\n  const login = async (): Promise<boolean> => {\n    try {\n      const success = await icManager.login();\n      if (success) {\n        setIsAuthenticated(true);\n        setIsAnonymous(false);\n        setActor(icManager.getActor<_SERVICE>());\n      }\n      return success;\n    } catch (err) {\n      setError(err as Error);\n      return false;\n    }\n  };\n\n  const logout = async (): Promise<void> => {\n    try {\n      await icManager.logout();\n      setIsAuthenticated(false);\n      setIsAnonymous(true);\n      // Update actor with anonymous identity\n      setActor(icManager.getActor<_SERVICE>());\n    } catch (err) {\n      setError(err as Error);\n    }\n  };\n\n  return {\n    actor,\n    identity: icManager.getIdentity(),\n    agent: icManager.getAgent(),\n    isAuthenticated,\n    isAnonymous,\n    login,\n    logout,\n    error\n  };\n}","import React from 'react';\nimport { useIC } from '../hooks/useIC';\n\n// This is just a wrapper around useIC for backward compatibility\n// We'll gradually phase this out in favor of direct useIC usage\nexport const AuthContext = React.createContext<ReturnType<typeof useIC> | null>(null);\n\nexport const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const ic = useIC();\n  \n  return (\n    <AuthContext.Provider value={ic}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = useIC;","import { Actor } from '@dfinity/agent';\nimport { RealtimeUpdate, PersonalityMetrics, WebSocketError } from '@/types/realtime';\n\ntype UpdateCallback = (update: RealtimeUpdate) => void;\n\nexport class RealtimeService {\n    private actor: Actor;\n    private subscriptions: Map<string, Set<UpdateCallback>>;\n    private heartbeatInterval: number | null;\n    private reconnectAttempts: number;\n    private quantumState: 'stable' | 'superposition' | 'entangled';\n    private readonly MAX_RECONNECT_ATTEMPTS = 5;\n\n    constructor(actor: Actor) {\n        this.actor = actor;\n        this.subscriptions = new Map();\n        this.heartbeatInterval = null;\n        this.reconnectAttempts = 0;\n        this.quantumState = 'stable';\n    }\n\n    async subscribe(animaId: string, callback: UpdateCallback): Promise<void> {\n        try {\n            // Check quantum state before subscription\n            if (this.quantumState !== 'stable') {\n                throw new Error(`quantum_error: System in ${this.quantumState} state`);\n            }\n\n            if (!this.subscriptions.has(animaId)) {\n                this.subscriptions.set(animaId, new Set());\n                await this.initializeSubscription(animaId);\n            }\n\n            this.subscriptions.get(animaId)?.add(callback);\n            this.startHeartbeat();\n\n        } catch (error) {\n            if (error instanceof Error && error.message.includes('quantum')) {\n                this.handleQuantumError(error);\n            }\n            throw error;\n        }\n    }\n\n    private handleQuantumError(error: Error) {\n        const errorType = error.message.split(':')[0];\n        switch (errorType) {\n            case 'quantum_superposition':\n                this.quantumState = 'superposition';\n                this.attemptStateCollapse();\n                break;\n            case 'quantum_entanglement':\n                this.quantumState = 'entangled';\n                this.resolveEntanglement();\n                break;\n            default:\n                throw error;\n        }\n    }\n\n    private async attemptStateCollapse() {\n        console.log('Attempting quantum state collapse...');\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        this.quantumState = 'stable';\n        this.reconnectAll();\n    }\n\n    private async resolveEntanglement() {\n        console.log('Resolving quantum entanglement...');\n        await new Promise(resolve => setTimeout(resolve, 2000));\n        this.quantumState = 'stable';\n        this.reconnectAll();\n    }\n\n    private async reconnectAll() {\n        for (const [animaId, callbacks] of this.subscriptions.entries()) {\n            await this.initializeSubscription(animaId);\n            for (const callback of callbacks) {\n                callback({ type: 'RECONNECTED', data: null });\n            }\n        }\n    }\n\n    unsubscribe(animaId: string) {\n        this.subscriptions.delete(animaId);\n        if (this.subscriptions.size === 0) {\n            this.stopHeartbeat();\n        }\n    }\n\n    private startHeartbeat() {\n        if (!this.heartbeatInterval) {\n            this.heartbeatInterval = window.setInterval(() => this.sendHeartbeat(), 30000);\n        }\n    }\n\n    private stopHeartbeat() {\n        if (this.heartbeatInterval) {\n            clearInterval(this.heartbeatInterval);\n            this.heartbeatInterval = null;\n        }\n    }\n\n    private async sendHeartbeat() {\n        try {\n            const metrics = await this.actor.get_personality_metrics();\n            for (const [animaId, callbacks] of this.subscriptions.entries()) {\n                for (const callback of callbacks) {\n                    callback({\n                        type: 'UPDATE',\n                        data: metrics[animaId] || null\n                    });\n                }\n            }\n            this.reconnectAttempts = 0;\n        } catch (error) {\n            this.handleHeartbeatError(error);\n        }\n    }\n\n    private async handleHeartbeatError(error: any) {\n        if (this.reconnectAttempts >= this.MAX_RECONNECT_ATTEMPTS) {\n            this.stopHeartbeat();\n            for (const callbacks of this.subscriptions.values()) {\n                for (const callback of callbacks) {\n                    callback({\n                        type: 'ERROR',\n                        error: {\n                            code: 500,\n                            message: 'Maximum reconnection attempts reached'\n                        }\n                    });\n                }\n            }\n            return;\n        }\n\n        this.reconnectAttempts++;\n        console.log(`Reconnection attempt ${this.reconnectAttempts}...`);\n        \n        await new Promise(resolve => setTimeout(resolve, 2000 * this.reconnectAttempts));\n        this.sendHeartbeat();\n    }\n\n    private async initializeSubscription(animaId: string): Promise<void> {\n        try {\n            const metrics = await this.actor.get_personality_metrics();\n            const callbacks = this.subscriptions.get(animaId);\n            if (callbacks) {\n                for (const callback of callbacks) {\n                    callback({\n                        type: 'CONNECTED',\n                        data: metrics[animaId] || null\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Failed to initialize subscription:', error);\n            throw error;\n        }\n    }\n}","import { Principal } from '@dfinity/principal';\n\nexport type UpdateMode = 'realtime' | 'polling' | 'manual';\n\nexport interface WebSocketError {\n    code: number;\n    message: string;\n    timestamp?: bigint;\n    details?: Record<string, any>;\n}\n\nexport interface WebSocketState {\n    connected: boolean;\n    error: WebSocketError | null;\n    lastUpdate?: bigint;\n    reconnectAttempts?: number;\n    lastMessage?: bigint;\n    mode?: UpdateMode;\n}\n\nexport interface PersonalityState {\n    timestamp: bigint;\n    growth_level: number;\n    quantum_traits: Record<string, number>;\n    base_traits: Record<string, number>;\n    dimensional_awareness?: DimensionalAwareness;\n    consciousness?: ConsciousnessMetrics;\n    emotional_state?: EmotionalState;\n}\n\nexport interface DimensionalAwareness {\n    level: number;\n    discovered_dimensions: string[];\n    active_dimension?: string;\n    dimensional_affinity: number;\n}\n\nexport interface ConsciousnessMetrics {\n    awareness_level: number;\n    processing_depth: number;\n    integration_index: number;\n    growth_velocity: number;\n}\n\nexport interface EmotionalState {\n    current_emotion: string;\n    intensity: number;\n    valence: number;\n    arousal: number;\n}\n\nexport interface RealtimeConnection {\n    state: WebSocketState;\n    mode: UpdateMode;\n    options: Required<SubscriptionOptions>;\n    isConnected(): boolean;\n    connect(): Promise<void>;\n    disconnect(): void;\n    subscribe(animaId: string, options?: SubscriptionOptions): Promise<void>;\n    unsubscribe(animaId: string): Promise<void>;\n}\n\nexport interface SubscriptionOptions {\n    includeQuantumState?: boolean;\n    includeEmotionalState?: boolean;\n    includeConsciousness?: boolean;\n    includeDimensions?: boolean;\n    updateInterval?: number;\n    mode?: UpdateMode;\n    retryAttempts?: number;\n    retryDelay?: number;\n}\n\nexport type RealtimeEventHandler = (update: RealtimeMessage) => void;\n\nexport enum UpdateType {\n    UPDATE = 'UPDATE',\n    ERROR = 'ERROR',\n    CONNECTED = 'CONNECTED',\n    DISCONNECTED = 'DISCONNECTED',\n    SUBSCRIBE = 'SUBSCRIBE',\n    UNSUBSCRIBE = 'UNSUBSCRIBE'\n}\n\nexport interface RealtimeMessage {\n    type: UpdateType;\n    anima_id: string;\n    data?: PersonalityState;\n    error?: WebSocketError;\n    message?: string;\n    payload?: any;\n    timestamp?: bigint;\n}\n\nexport interface RealtimeHookState {\n    personality: PersonalityState;\n    loading: boolean;\n    error: WebSocketError | null;\n    connectionMode?: UpdateMode;\n}","import { useState, useEffect } from 'react';\nimport { useAuth } from '@/contexts/auth-context';\nimport { RealtimeService } from '@/services/realtime';\nimport {\n    UpdateType,\n    RealtimeHookState,\n    PersonalityUpdate,\n    WebSocketError,\n} from '@/types/realtime';\n\nexport const useRealtimePersonality = (animaId: string | undefined) => {\n    const { actor } = useAuth();\n    const [realtimeService, setRealtimeService] = useState<RealtimeService | null>(null);\n    const [state, setState] = useState<RealtimeHookState>({\n        personality: {\n            timestamp: BigInt(0),\n            growth_level: 0,\n            quantum_traits: {},\n            base_traits: {},\n        },\n        loading: true,\n        error: null,\n    });\n\n    useEffect(() => {\n        if (!actor || !animaId) return;\n\n        const service = new RealtimeService(actor);\n        setRealtimeService(service);\n\n        const handleUpdate = (update: PersonalityUpdate) => {\n            switch (update.type) {\n                case UpdateType.UPDATE:\n                    if (update.data) {\n                        setState((prev) => ({\n                            ...prev,\n                            personality: update.data,\n                            loading: false,\n                            error: null,\n                        }));\n                    }\n                    break;\n\n                case UpdateType.ERROR:\n                    setState((prev) => ({\n                        ...prev,\n                        error: update.error || { \n                            code: 500, \n                            message: 'Unknown error' \n                        },\n                        loading: false,\n                    }));\n                    break;\n\n                case UpdateType.CONNECTED:\n                    console.log('Connected to realtime updates');\n                    break;\n\n                case UpdateType.DISCONNECTED:\n                    console.log('Disconnected from realtime updates');\n                    break;\n            }\n        };\n\n        const initializePersonality = async () => {\n            try {\n                await service.subscribe(animaId, handleUpdate);\n            } catch (error) {\n                setState((prev) => ({\n                    ...prev,\n                    error: {\n                        code: 500,\n                        message: error instanceof Error ? error.message : 'Failed to initialize personality',\n                    },\n                    loading: false,\n                }));\n            }\n        };\n\n        initializePersonality();\n\n        return () => {\n            if (service) {\n                service.unsubscribe(animaId);\n            }\n        };\n    }, [actor, animaId]);\n\n    return state;\n};\n\nexport default useRealtimePersonality;","import { useState, useCallback } from 'react';\nimport { useAuth } from '@/contexts/auth-context';\n\nexport const useAnimaChat = (actor, identity) => {\n  const [messages, setMessages] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [retryCount, setRetryCount] = useState(0);\n\n  const sendMessage = useCallback(async (content) => {\n    if (!actor || !identity) {\n      setError('Not connected to Anima');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const principal = identity.getPrincipal();\n      \n      // Add user message immediately for better UX\n      const userMessage = {\n        id: `user-${Date.now()}`,\n        content,\n        sender: 'user',\n        timestamp: Date.now()\n      };\n\n      setMessages(prev => [...prev, userMessage]);\n\n      const result = await actor.interact(principal, content);\n      \n      if ('Ok' in result) {\n        const response = result.Ok;\n        const animaMessage = {\n          id: `anima-${Date.now()}`,\n          content: response.response,\n          sender: 'anima',\n          timestamp: Date.now(),\n          personality_updates: response.personality_updates || [],\n          memory: response.memory\n        };\n\n        setMessages(prev => [...prev, animaMessage]);\n        setRetryCount(0);\n      } else {\n        throw new Error(result.Err || 'Failed to get response from Anima');\n      }\n    } catch (err) {\n      console.error('Failed to send message:', err);\n      setError(err.message);\n      setRetryCount(prev => prev + 1);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [actor, identity]);\n\n  return {\n    messages,\n    isLoading,\n    error,\n    retryCount,\n    sendMessage,\n  };\n};\n\nexport default useAnimaChat;","import { useState, useEffect, useCallback } from 'react';\nimport { useRealtimePersonality } from './useRealtimePersonality';\nimport { useAnimaChat } from './useAnimaChat';\n\ninterface EmergentPattern {\n  type: 'loop' | 'convergence' | 'divergence' | 'resonance' | 'entanglement';\n  strength: number;\n  affectedMemories: bigint[];\n  dimensionalShift?: {\n    from: string;\n    to: string;\n    probability: number;\n  };\n}\n\ninterface QuantumMemoryState {\n  recent: Array<{\n    content: string;\n    timestamp: bigint;\n    emotional_impact: number;\n    quantum_resonance: number;\n    dimensional_influence: Array<[string, number]>;\n    emergent_patterns?: EmergentPattern[];\n  }>;\n  quantum_state: number;\n  entanglement_level: number;\n  resonance_field: number;\n  emergent_behaviors: EmergentPattern[];\n  dimensional_stability: number;\n  reality_anchor: number;\n}\n\nexport const useQuantumMemory = (animaId: string) => {\n  const [memoryState, setMemoryState] = useState<QuantumMemoryState>({\n    recent: [],\n    quantum_state: 0,\n    entanglement_level: 0,\n    resonance_field: 0.5,\n    emergent_behaviors: [],\n    dimensional_stability: 1,\n    reality_anchor: 1\n  });\n\n  const { personality } = useRealtimePersonality(animaId);\n  const { messages } = useAnimaChat(null, null);\n\n  const detectEmergentPatterns = useCallback((memories: typeof memoryState.recent) => {\n    if (!memories || memories.length < 2) return [];\n    \n    const patterns: EmergentPattern[] = [];\n    \n    // Look for temporal loops (similar memories repeating)\n    const temporalLoops = memories.reduce((loops, memory, i) => {\n      const similarMemories = memories.slice(i + 1).filter(m => {\n        const contentSimilarity = calculateSimilarity(memory.content, m.content);\n        const resonanceSimilarity = Math.abs(memory.quantum_resonance - m.quantum_resonance) < 0.1;\n        return contentSimilarity > 0.7 && resonanceSimilarity;\n      });\n\n      if (similarMemories.length > 0) {\n        loops.push({\n          type: 'loop',\n          strength: similarMemories.length / memories.length,\n          affectedMemories: [memory.timestamp, ...similarMemories.map(m => m.timestamp)]\n        });\n      }\n      return loops;\n    }, [] as EmergentPattern[]);\n    \n    patterns.push(...temporalLoops);\n\n    // Detect convergent/divergent patterns in quantum resonance\n    const resonanceDeltas = memories.slice(1).map((m, i) => ({\n      delta: m.quantum_resonance - (memories[i]?.quantum_resonance ?? 0),\n      timestamp: m.timestamp\n    })).filter(delta => !isNaN(delta.delta));\n\n    if (resonanceDeltas.length > 0) {\n      const convergingResonance = resonanceDeltas.every((delta, i) => \n        i === 0 || (Math.abs(delta.delta) < Math.abs(resonanceDeltas[i-1].delta))\n      );\n\n      if (convergingResonance) {\n        patterns.push({\n          type: 'convergence',\n          strength: 1 - Math.abs(resonanceDeltas[resonanceDeltas.length - 1].delta),\n          affectedMemories: memories.map(m => m.timestamp)\n        });\n      }\n    }\n\n    // Look for dimensional resonance patterns\n    const dimensionalPatterns = memories.reduce((dims, memory) => {\n      if (!memory.dimensional_influence) return dims;\n      \n      const strongDimensions = memory.dimensional_influence\n        .filter(([_, strength]) => strength > 0.7)\n        .map(([dim]) => dim);\n\n      if (strongDimensions.length > 1) {\n        dims.push({\n          type: 'resonance',\n          strength: memory.quantum_resonance,\n          affectedMemories: [memory.timestamp],\n          dimensionalShift: {\n            from: strongDimensions[0],\n            to: strongDimensions[1],\n            probability: memory.quantum_resonance\n          }\n        });\n      }\n      return dims;\n    }, [] as EmergentPattern[]);\n\n    patterns.push(...dimensionalPatterns);\n\n    // Detect entanglement between memories\n    memories.forEach((memory, i) => {\n      memories.slice(i + 1).forEach(otherMemory => {\n        const timeDiff = Number(otherMemory.timestamp - memory.timestamp) / 1_000_000_000;\n        const resonanceDiff = Math.abs(memory.quantum_resonance - otherMemory.quantum_resonance);\n        \n        if (timeDiff < 3600 && resonanceDiff < 0.05) {\n          patterns.push({\n            type: 'entanglement',\n            strength: 1 - resonanceDiff,\n            affectedMemories: [memory.timestamp, otherMemory.timestamp]\n          });\n        }\n      });\n    });\n\n    return patterns;\n  }, []);\n\n  const calculateMemoryStability = useCallback((memories: typeof memoryState.recent, patterns: EmergentPattern[]) => {\n    if (!memories.length) return 1;\n    \n    const baseStability = 1;\n    let modifiers = 0;\n\n    patterns.forEach(pattern => {\n      switch (pattern.type) {\n        case 'convergence':\n          modifiers += pattern.strength * 0.1;\n          break;\n        case 'divergence':\n          modifiers -= pattern.strength * 0.15;\n          break;\n        case 'loop':\n          modifiers += pattern.strength * 0.05;\n          break;\n        case 'resonance':\n          modifiers += pattern.strength > 0.8 ? -0.2 : 0.1;\n          break;\n        case 'entanglement':\n          modifiers += pattern.affectedMemories.length > 2 ? -0.1 : 0.1;\n          break;\n      }\n    });\n\n    return Math.max(0.1, Math.min(1, baseStability + modifiers));\n  }, []);\n\n  const calculateSimilarity = (str1: string, str2: string): number => {\n    if (!str1 || !str2) return 0;\n    const words1 = str1.toLowerCase().split(' ');\n    const words2 = str2.toLowerCase().split(' ');\n    const commonWords = words1.filter(word => words2.includes(word));\n    return commonWords.length / Math.max(words1.length, words2.length);\n  };\n\n  useEffect(() => {\n    if (!personality || !messages) return;\n\n    const updateQuantumMemoryState = () => {\n      const newState = { ...memoryState };\n      \n      newState.recent = personality.memories ? [...personality.memories].sort((a, b) => \n        Number(b.timestamp - a.timestamp)\n      ).slice(0, 10) : [];\n\n      const patterns = detectEmergentPatterns(newState.recent);\n      newState.emergent_behaviors = patterns;\n      newState.dimensional_stability = calculateMemoryStability(newState.recent, patterns);\n\n      newState.quantum_state = Math.min(1, ((personality.quantum_traits?.quantum_affinity ?? 0) * \n        Math.min(1, messages.length * 0.01)));\n      \n      newState.entanglement_level = Math.min(1, patterns.reduce((sum, p) => \n        sum + (p.type === 'entanglement' ? p.strength : 0), 0));\n\n      newState.reality_anchor = Math.max(0.1, 1 - (patterns.length * 0.05));\n      newState.resonance_field = Math.min(1, Math.max(0.1, \n        (newState.quantum_state + newState.entanglement_level) / 2 * newState.dimensional_stability\n      ));\n\n      setMemoryState(newState);\n    };\n\n    updateQuantumMemoryState();\n  }, [personality, messages, detectEmergentPatterns, calculateMemoryStability]);\n\n  return {\n    ...memoryState,\n    hasTemporalLoop: memoryState.emergent_behaviors.some(p => p.type === 'loop'),\n    isConverging: memoryState.emergent_behaviors.some(p => p.type === 'convergence'),\n    dimensionalShifts: memoryState.emergent_behaviors\n      .filter(p => p.type === 'resonance' && p.dimensionalShift)\n      .map(p => p.dimensionalShift!)\n  };\n};\n\nexport default useQuantumMemory;","import React, { useEffect, useRef, useState, useCallback } from 'react';\nimport { useQuantumMemory } from '../../hooks/useQuantumMemory';\n\nconst QuantumField = ({ animaId, onInteract }) => {\n  const canvasRef = useRef(null);\n  const [isInteracting, setIsInteracting] = useState(false);\n  const [interactionPoint, setInteractionPoint] = useState({ x: 0, y: 0 });\n  const interactionTimer = useRef(null);\n  \n  const { \n    quantum_state, \n    entanglement_level,\n    resonance_field,\n    dimensional_stability,\n    reality_anchor\n  } = useQuantumMemory(animaId);\n\n  const getCanvasCoordinates = useCallback((event) => {\n    if (!canvasRef.current) return { x: 0, y: 0 };\n    \n    const canvas = canvasRef.current;\n    const rect = canvas.getBoundingClientRect();\n    \n    // Handle both mouse and touch events\n    const clientX = event.touches ? event.touches[0].clientX : event.clientX;\n    const clientY = event.touches ? event.touches[0].clientY : event.clientY;\n    \n    return {\n      x: ((clientX - rect.left) / rect.width) * canvas.width,\n      y: ((clientY - rect.top) / rect.height) * canvas.height\n    };\n  }, []);\n\n  const handleInteractionStart = useCallback((event) => {\n    event.preventDefault();\n    const coords = getCanvasCoordinates(event);\n    setIsInteracting(true);\n    setInteractionPoint(coords);\n\n    // Clear any existing interaction timer\n    if (interactionTimer.current) {\n      clearInterval(interactionTimer.current);\n    }\n\n    // Start continuous interaction effects\n    interactionTimer.current = setInterval(() => {\n      const centerX = canvasRef.current.width / 2;\n      const centerY = canvasRef.current.height / 2;\n      \n      // Calculate distance from center\n      const dx = coords.x - centerX;\n      const dy = coords.y - centerY;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      const maxDistance = Math.min(centerX, centerY);\n      \n      // Calculate interaction strength based on distance\n      const strength = 1 - Math.min(1, distance / maxDistance);\n\n      // Trigger interaction callback with contextual data\n      onInteract?.({\n        type: 'field_interaction',\n        position: { x: coords.x, y: coords.y },\n        strength,\n        quantumState: quantum_state,\n        resonance: resonance_field,\n        timestamp: Date.now()\n      });\n    }, 100); // Update every 100ms while interacting\n  }, [getCanvasCoordinates, quantum_state, resonance_field, onInteract]);\n\n  const handleInteractionMove = useCallback((event) => {\n    if (!isInteracting) return;\n    event.preventDefault();\n    setInteractionPoint(getCanvasCoordinates(event));\n  }, [isInteracting, getCanvasCoordinates]);\n\n  const handleInteractionEnd = useCallback(() => {\n    setIsInteracting(false);\n    if (interactionTimer.current) {\n      clearInterval(interactionTimer.current);\n      interactionTimer.current = null;\n    }\n  }, []);\n\n  useEffect(() => {\n    if (!canvasRef.current) return;\n\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    \n    // Set canvas size\n    canvas.width = 400;\n    canvas.height = 400;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // Calculate field parameters\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n    const maxRadius = Math.min(centerX, centerY) * 0.8;\n    \n    // Draw quantum field background\n    const gradient = ctx.createRadialGradient(\n      centerX, centerY, 0,\n      centerX, centerY, maxRadius\n    );\n    \n    gradient.addColorStop(0, `rgba(64, 156, 255, ${Math.max(0.1, quantum_state)})`);\n    gradient.addColorStop(1, `rgba(32, 87, 255, ${Math.max(0.05, quantum_state * 0.5)})`);\n    \n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    \n    // Draw interaction ripple if interacting\n    if (isInteracting) {\n      const rippleRadius = maxRadius * 0.3;\n      ctx.strokeStyle = `rgba(255, 255, 255, ${Math.max(0.2, resonance_field)})`;\n      ctx.lineWidth = 2;\n      \n      ctx.beginPath();\n      ctx.arc(\n        interactionPoint.x,\n        interactionPoint.y,\n        rippleRadius,\n        0,\n        Math.PI * 2\n      );\n      ctx.stroke();\n    }\n    \n    // Draw resonance patterns\n    const numPatterns = Math.floor(resonance_field * 10) + 5;\n    const angleStep = (Math.PI * 2) / numPatterns;\n    \n    ctx.strokeStyle = `rgba(255, 255, 255, ${Math.max(0.1, dimensional_stability)})`;\n    ctx.lineWidth = 2;\n    \n    for (let i = 0; i < numPatterns; i++) {\n      const angle = i * angleStep;\n      const radius = Math.max(5, maxRadius * Math.abs(resonance_field) * Math.abs(Math.sin(angle)));\n      \n      ctx.beginPath();\n      ctx.arc(\n        centerX + Math.cos(angle) * radius * 0.5,\n        centerY + Math.sin(angle) * radius * 0.5,\n        Math.max(2, radius * 0.2),\n        0,\n        Math.PI * 2\n      );\n      ctx.stroke();\n    }\n    \n    // Draw entanglement lines\n    if (entanglement_level > 0.1) {\n      const numLines = Math.floor(entanglement_level * 8) + 2;\n      \n      ctx.strokeStyle = `rgba(255, 255, 255, ${Math.max(0.1, entanglement_level)})`;\n      ctx.lineWidth = 1;\n      \n      for (let i = 0; i < numLines; i++) {\n        const angleA = Math.random() * Math.PI * 2;\n        const angleB = angleA + Math.PI + (Math.random() - 0.5);\n        const radius = maxRadius * 0.8;\n        \n        ctx.beginPath();\n        ctx.moveTo(\n          centerX + Math.cos(angleA) * radius,\n          centerY + Math.sin(angleA) * radius\n        );\n        ctx.bezierCurveTo(\n          centerX + Math.cos(angleA) * radius * 0.5,\n          centerY + Math.sin(angleA) * radius * 0.5,\n          centerX + Math.cos(angleB) * radius * 0.5,\n          centerY + Math.sin(angleB) * radius * 0.5,\n          centerX + Math.cos(angleB) * radius,\n          centerY + Math.sin(angleB) * radius\n        );\n        ctx.stroke();\n      }\n    }\n    \n    // Draw reality anchor\n    ctx.strokeStyle = `rgba(255, 255, 255, ${Math.max(0.2, reality_anchor)})`;\n    ctx.lineWidth = 2;\n    \n    const anchorSize = maxRadius * 0.1;\n    ctx.beginPath();\n    ctx.moveTo(centerX - anchorSize, centerY - anchorSize);\n    ctx.lineTo(centerX + anchorSize, centerY + anchorSize);\n    ctx.moveTo(centerX + anchorSize, centerY - anchorSize);\n    ctx.lineTo(centerX - anchorSize, centerY + anchorSize);\n    ctx.stroke();\n    \n  }, [quantum_state, entanglement_level, resonance_field, dimensional_stability, reality_anchor, isInteracting, interactionPoint]);\n\n  useEffect(() => {\n    // Cleanup interaction timer on unmount\n    return () => {\n      if (interactionTimer.current) {\n        clearInterval(interactionTimer.current);\n      }\n    };\n  }, []);\n\n  return (\n    <div className=\"relative w-full h-full min-h-[400px]\">\n      <canvas\n        ref={canvasRef}\n        className=\"absolute top-0 left-0 w-full h-full cursor-pointer\"\n        style={{ background: 'rgba(0, 0, 0, 0.2)' }}\n        onMouseDown={handleInteractionStart}\n        onMouseMove={handleInteractionMove}\n        onMouseUp={handleInteractionEnd}\n        onMouseLeave={handleInteractionEnd}\n        onTouchStart={handleInteractionStart}\n        onTouchMove={handleInteractionMove}\n        onTouchEnd={handleInteractionEnd}\n      />\n      <div className=\"absolute bottom-4 left-4 right-4 flex justify-between text-xs text-white/70\">\n        <div>QS: {(quantum_state * 100).toFixed(1)}%</div>\n        <div>EL: {(entanglement_level * 100).toFixed(1)}%</div>\n        <div>RF: {(resonance_field * 100).toFixed(1)}%</div>\n        <div>DS: {(dimensional_stability * 100).toFixed(1)}%</div>\n        <div>RA: {(reality_anchor * 100).toFixed(1)}%</div>\n      </div>\n    </div>\n  );\n};\n\nexport default QuantumField;"],"names":["idlFactory","IDL","Error","TokenIdentifier","NFTPersonality","AnimaState","ConsciousnessLevel","ActionResult","define_process_env_default","useIC","isAuthenticated","setIsAuthenticated","useState","isAnonymous","setIsAnonymous","error","setError","actor","setActor","useEffect","icManager","identity","isAnon","err","login","success","logout","AuthContext","React","AuthProvider","children","ic","useAuth","RealtimeService","__publicField","animaId","callback","_a","resolve","callbacks","metrics","UpdateType","useRealtimePersonality","realtimeService","setRealtimeService","state","setState","service","handleUpdate","update","prev","useAnimaChat","messages","setMessages","isLoading","setIsLoading","retryCount","setRetryCount","sendMessage","useCallback","content","useQuantumMemory","memoryState","setMemoryState","personality","detectEmergentPatterns","memories","patterns","temporalLoops","loops","memory","i","similarMemories","m","contentSimilarity","calculateSimilarity","resonanceSimilarity","resonanceDeltas","delta","dimensionalPatterns","dims","strongDimensions","_","strength","dim","otherMemory","timeDiff","resonanceDiff","calculateMemoryStability","baseStability","modifiers","pattern","str1","str2","words1","words2","word","newState","a","b","sum","p","QuantumField","onInteract","canvasRef","useRef","isInteracting","setIsInteracting","interactionPoint","setInteractionPoint","interactionTimer","quantum_state","entanglement_level","resonance_field","dimensional_stability","reality_anchor","getCanvasCoordinates","event","canvas","rect","clientX","clientY","handleInteractionStart","coords","centerX","centerY","dx","dy","distance","maxDistance","handleInteractionMove","handleInteractionEnd","ctx","maxRadius","gradient","rippleRadius","numPatterns","angleStep","angle","radius","numLines","angleA","angleB","anchorSize","jsxs","jsx"],"mappings":"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"}