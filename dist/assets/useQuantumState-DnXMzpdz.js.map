{"version":3,"file":"useQuantumState-DnXMzpdz.js","sources":["../../src/quantum/dimensional_state.ts","../../src/hooks/useQuantumState.ts"],"sourcesContent":["import { DimensionalState, ResonancePattern } from './types';\n\nexport class DimensionalStateImpl implements DimensionalState {\n  public frequency: number;\n  public resonance: number;\n  public stability: number;\n  public syncLevel: number;\n  public quantumAlignment: number;\n  public dimensionalFrequency: number;\n  public entropyLevel: number;\n  public phaseCoherence: number;\n  private lastUpdate: number;\n  private readonly BASE_DEGRADATION_RATE = 0.995;\n  private readonly PATTERN_COHERENCE_THRESHOLD = 0.7;\n  private readonly MAX_ENTROPY_INCREASE = 0.2;\n  private readonly MIN_INTERACTION_THRESHOLD = 0.1;\n\n  constructor() {\n    this.frequency = 0.0;\n    this.resonance = 1.0;\n    this.stability = 1.0;\n    this.syncLevel = 1.0;\n    this.quantumAlignment = 1.0;\n    this.dimensionalFrequency = 0.0;\n    this.entropyLevel = 0.0;\n    this.phaseCoherence = 1.0;\n    this.lastUpdate = Date.now();\n  }\n\n  calculateResonance(): number {\n    this.applyQuantumDegradation();\n    \n    const baseResonance = this.resonance * this.stability;\n    const alignmentFactor = this.quantumAlignment * this.syncLevel;\n    const entropyModifier = this.calculateEntropyModifier();\n    const coherenceBoost = this.calculateCoherenceBoost();\n    const temporalFactor = this.calculateTemporalFactor();\n    \n    // Apply non-linear quantum effects while preserving original behavior\n    const quantumEffect = Math.sin(this.dimensionalFrequency * Math.PI) * 0.1;\n    \n    return Math.min(1.0, Math.max(0.0,\n      ((baseResonance + alignmentFactor) / 2.0 * entropyModifier + coherenceBoost) * \n      temporalFactor + quantumEffect\n    ));\n  }\n\n  private calculateEntropyModifier(): number {\n    const baseEntropy = 1.0 - (this.entropyLevel * 0.5);\n    const quantumEntropy = Math.cos(this.dimensionalFrequency * Math.PI) * 0.1;\n    return Math.max(0.1, baseEntropy + quantumEntropy);\n  }\n\n  private calculateCoherenceBoost(): number {\n    const baseBoost = this.phaseCoherence * 0.2;\n    const resonanceBoost = Math.sin(this.resonance * Math.PI) * 0.1;\n    return baseBoost + resonanceBoost;\n  }\n\n  private calculateTemporalFactor(): number {\n    const timeDelta = this.getTimeSinceLastUpdate();\n    const dilationFactor = 1 + (this.dimensionalFrequency * 0.1);\n    return Math.exp(-timeDelta / (10000 * dilationFactor));\n  }\n\n  updateStability(interactionStrength: number): void {\n    this.applyQuantumDegradation();\n\n    const timeBonus = Math.max(0, 1 - this.getTimeSinceLastUpdate() / 5000);\n    const effectiveStrength = interactionStrength * timeBonus;\n\n    // Enhanced stability updates with quantum considerations\n    this.stability = Math.min(1.0, Math.max(0.0, \n      this.stability + effectiveStrength * (1 + this.dimensionalFrequency * 0.1)\n    ));\n    \n    this.quantumAlignment = Math.min(1.0,\n      this.quantumAlignment + effectiveStrength * 0.5 * (1 - this.entropyLevel * 0.2)\n    );\n    \n    this.syncLevel = Math.min(1.0,\n      this.syncLevel + effectiveStrength * 0.3 * (1 + this.phaseCoherence * 0.1)\n    );\n    \n    this.dimensionalFrequency = Math.min(1.0,\n      this.dimensionalFrequency + effectiveStrength * 0.2\n    );\n    \n    // Enhanced entropy and phase coherence updates\n    this.entropyLevel = Math.max(0.0,\n      this.entropyLevel - effectiveStrength * 0.1 * (1 + this.quantumAlignment * 0.1)\n    );\n    \n    this.phaseCoherence = Math.min(1.0,\n      this.phaseCoherence + effectiveStrength * 0.4 * (1 - this.entropyLevel * 0.1)\n    );\n\n    this.lastUpdate = Date.now();\n  }\n\n  private applyQuantumDegradation(): void {\n    const timePassed = this.getTimeSinceLastUpdate();\n    if (timePassed > 1000) {\n      const degradationFactor = this.calculateDegradationFactor(timePassed);\n      \n      // Apply non-linear degradation while preserving stability\n      this.stability *= degradationFactor;\n      this.quantumAlignment *= degradationFactor * (1 + this.dimensionalFrequency * 0.1);\n      this.syncLevel *= degradationFactor * (1 - this.entropyLevel * 0.1);\n      this.phaseCoherence *= degradationFactor * (1 + this.resonance * 0.1);\n      \n      // Enhanced entropy evolution\n      this.evolveEntropy(degradationFactor);\n\n      this.lastUpdate = Date.now();\n    }\n  }\n\n  private calculateDegradationFactor(timePassed: number): number {\n    const baseDegradation = Math.pow(this.BASE_DEGRADATION_RATE, timePassed / 1000);\n    const quantumFactor = 1 + (Math.sin(this.dimensionalFrequency * Math.PI) * 0.05);\n    return baseDegradation * quantumFactor;\n  }\n\n  private evolveEntropy(degradationFactor: number): void {\n    const entropyIncrease = (1 - degradationFactor) * this.MAX_ENTROPY_INCREASE;\n    const quantumEntropy = Math.sin(this.dimensionalFrequency * Math.PI) * 0.05;\n    \n    this.entropyLevel = Math.min(1.0,\n      this.entropyLevel + entropyIncrease + quantumEntropy\n    );\n  }\n\n  getStabilityMetrics(): [number, number, number] {\n    this.applyQuantumDegradation();\n    \n    const baseMetrics = [this.stability, this.quantumAlignment, this.phaseCoherence];\n    const quantumInfluence = Math.sin(this.dimensionalFrequency * Math.PI) * 0.1;\n    \n    return baseMetrics.map(metric => \n      Math.min(1.0, Math.max(0.0, metric + quantumInfluence))\n    ) as [number, number, number];\n  }\n\n  private getTimeSinceLastUpdate(): number {\n    return Date.now() - this.lastUpdate;\n  }\n\n  async emergencyRecovery(): Promise<boolean> {\n    const currentStatus = this.getQuantumStatus();\n    if (currentStatus === 'critical') {\n      // Attempt quantum state restoration while preserving patterns\n      this.stability = Math.max(0.3, this.stability);\n      this.quantumAlignment = Math.max(0.3, this.quantumAlignment);\n      this.syncLevel = Math.max(0.3, this.syncLevel);\n      this.phaseCoherence = Math.max(0.3, this.phaseCoherence);\n      this.entropyLevel = Math.min(0.7, this.entropyLevel);\n      \n      return true;\n    }\n    return false;\n  }\n\n  getQuantumStatus(): 'stable' | 'unstable' | 'critical' {\n    const metrics = this.getStabilityMetrics();\n    const avgMetric = metrics.reduce((a, b) => a + b, 0) / metrics.length;\n    const entropyFactor = 1 - this.entropyLevel;\n    const effectiveMetric = avgMetric * entropyFactor;\n    \n    if (effectiveMetric > 0.7) return 'stable';\n    if (effectiveMetric > 0.3) return 'unstable';\n    return 'critical';\n  }\n\n  checkPatternResonance(pattern: ResonancePattern): boolean {\n    const timeDecay = Math.exp(-(Date.now() - pattern.timestamp) / 10000);\n    const coherenceCheck = pattern.coherence * timeDecay > this.PATTERN_COHERENCE_THRESHOLD;\n    const frequencyMatch = Math.abs(pattern.frequency - this.dimensionalFrequency) < 0.2;\n    \n    return coherenceCheck && frequencyMatch;\n  }\n}","import { useState, useEffect, useCallback, useRef } from 'react';\nimport { useAuth } from './useAuth';\nimport { Principal } from '@dfinity/principal';\nimport { DimensionalStateImpl } from '../quantum/dimensional_state';\nimport { useConsciousness } from './useConsciousness';\nimport { BirthCertificate } from '../nft/types';\n\ninterface QuantumState {\n  stabilityStatus: 'stable' | 'unstable' | 'critical';\n  coherenceLevel: number;\n  entanglementIndex: number;\n  quantumSignature: string;\n  dimensionalState: DimensionalStateImpl;\n  lastUpdate: number;\n  resonancePatterns?: ResonancePattern[];\n  birthCertificate?: BirthCertificate;\n  consciousnessAlignment?: number;\n  isInitialized: boolean;\n}\n\ninterface ResonancePattern {\n  frequency: number;\n  amplitude: number;\n  phase: number;\n  coherence: number;\n}\n\nexport const useQuantumState = () => {\n  const { identity } = useAuth();\n  const { consciousness, isInitialized: isConsciousnessInitialized } = useConsciousness();\n  const initializationAttempted = useRef(false);\n  const [initializationError, setInitializationError] = useState<Error | null>(null);\n  const [isInitializing, setIsInitializing] = useState(false);\n  const initializationTimeoutRef = useRef<NodeJS.Timeout>();\n\n  const [state, setState] = useState<QuantumState>(() => {\n    console.log(\"ðŸŒ€ Creating initial quantum state\");\n    return {\n      stabilityStatus: 'unstable',\n      coherenceLevel: 0.5,\n      entanglementIndex: 0.3,\n      quantumSignature: '',\n      dimensionalState: new DimensionalStateImpl(),\n      lastUpdate: Date.now(),\n      isInitialized: false\n    };\n  });\n\n  // Clear timeout on unmount\n  useEffect(() => {\n    return () => {\n      if (initializationTimeoutRef.current) {\n        clearTimeout(initializationTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  // Initialize quantum state based on principal\n  useEffect(() => {\n    if (!identity || !isConsciousnessInitialized || initializationAttempted.current || isInitializing) {\n      console.log(\"ðŸ” Skipping initialization:\", { \n        hasIdentity: !!identity, \n        consciousnessReady: isConsciousnessInitialized,\n        wasAttempted: initializationAttempted.current,\n        isInitializing \n      });\n      return;\n    }\n    \n    const initialize = async () => {\n      console.log(\"ðŸŒŸ Starting quantum state initialization\");\n      setIsInitializing(true);\n      initializationAttempted.current = true;\n\n      // Set initialization timeout\n      initializationTimeoutRef.current = setTimeout(() => {\n        if (!state.isInitialized) {\n          console.error(\"âš ï¸ Quantum state initialization timeout\");\n          setInitializationError(new Error(\"Initialization timeout\"));\n          setState(prev => ({ \n            ...prev, \n            isInitialized: true,\n            stabilityStatus: 'critical'\n          }));\n        }\n      }, 15000); // 15 second timeout\n\n      try {\n        const principal = identity.getPrincipal();\n        const principalArray = principal.toUint8Array();\n        \n        console.log(\"ðŸ“Š Calculating initial coherence...\");\n        const initialCoherence = Math.max(0.5, principalArray.reduce((acc, byte) => acc + byte, 0) / \n          (principalArray.length * 255));\n        \n        // Add consciousness boost if available\n        const consciousnessBoost = consciousness?.level ? consciousness.level * 0.2 : 0;\n        const adjustedCoherence = Math.min(1.0, initialCoherence + consciousnessBoost);\n        \n        console.log(\"ðŸ”® Initializing dimensional state...\");\n        const dimensionalState = new DimensionalStateImpl();\n        dimensionalState.updateStability(adjustedCoherence);\n\n        const quantumSignature = await generateQuantumSignature(principal, adjustedCoherence);\n\n        // Generate initial resonance patterns\n        const resonancePatterns = Array.from({ length: 4 }, (_, i) => ({\n          frequency: 0.5 + (Math.random() * 0.5),\n          amplitude: 0.3 + (Math.random() * 0.7),\n          phase: Math.random() * Math.PI * 2,\n          coherence: adjustedCoherence * (0.8 + Math.random() * 0.2)\n        }));\n\n        console.log(\"âœ¨ Setting initial state...\");\n        setState(prev => ({\n          ...prev,\n          coherenceLevel: adjustedCoherence,\n          entanglementIndex: adjustedCoherence * 0.8,\n          dimensionalState,\n          quantumSignature,\n          resonancePatterns,\n          consciousnessAlignment: consciousness?.level ? consciousness.level * adjustedCoherence : undefined,\n          lastUpdate: Date.now(),\n          isInitialized: true,\n          stabilityStatus: 'stable'\n        }));\n\n        console.log(\"âœ… Quantum state initialized successfully!\");\n      } catch (error) {\n        console.error(\"âŒ Failed to initialize quantum state:\", error);\n        setInitializationError(error as Error);\n        setState(prev => ({ \n          ...prev, \n          isInitialized: true,\n          stabilityStatus: 'critical'\n        }));\n      } finally {\n        setIsInitializing(false);\n        if (initializationTimeoutRef.current) {\n          clearTimeout(initializationTimeoutRef.current);\n        }\n      }\n    };\n\n    initialize();\n  }, [identity, isConsciousnessInitialized, consciousness?.level]);\n\n  // Update quantum state periodically\n  useEffect(() => {\n    if (!state.isInitialized || isInitializing) return;\n\n    console.log(\"âš¡ Starting quantum state updates\");\n    const intervalId = setInterval(() => {\n      setState(prev => {\n        if (!prev.isInitialized) return prev;\n\n        const timePassed = (Date.now() - prev.lastUpdate) / 1000;\n        const degradationFactor = Math.pow(0.995, timePassed);\n        const consciousnessBoost = consciousness?.level ? consciousness.level * 0.1 : 0;\n\n        // Update dimensional state\n        prev.dimensionalState.updateStability(consciousnessBoost - 0.01);\n        const metrics = prev.dimensionalState.getStabilityMetrics();\n\n        // Calculate new coherence with consciousness protection\n        const consciousnessProtection = consciousness?.level ? Math.min(0.3, consciousness.level) : 0;\n        const minCoherence = 0.1 + consciousnessProtection;\n        const newCoherence = Math.max(minCoherence, prev.coherenceLevel * degradationFactor);\n\n        // Update resonance patterns\n        const updatedPatterns = prev.resonancePatterns?.map(pattern => ({\n          ...pattern,\n          coherence: Math.max(minCoherence, pattern.coherence * degradationFactor),\n          phase: (pattern.phase + 0.1) % (Math.PI * 2)\n        }));\n        \n        return {\n          ...prev,\n          coherenceLevel: newCoherence,\n          entanglementIndex: Math.max(minCoherence, prev.entanglementIndex * degradationFactor),\n          stabilityStatus: prev.dimensionalState.getQuantumStatus(),\n          consciousnessAlignment: consciousness?.level ? consciousness.level * newCoherence : undefined,\n          resonancePatterns: updatedPatterns,\n          lastUpdate: Date.now()\n        };\n      });\n    }, 3000);\n\n    return () => {\n      console.log(\"ðŸ”„ Cleaning up quantum state updates\");\n      clearInterval(intervalId);\n    };\n  }, [state.isInitialized, isInitializing, consciousness?.level]);\n\n  return {\n    state,\n    isInitialized: state.isInitialized && !isInitializing,\n    isInitializing,\n    error: initializationError,\n    updateQuantumState: useCallback(async (updates: Partial<QuantumState>) => {\n      setState(prev => ({\n        ...prev,\n        ...updates,\n        lastUpdate: Date.now()\n      }));\n    }, []),\n  };\n};\n\nasync function generateQuantumSignature(principal: Principal, coherence: number): Promise<string> {\n  // Add artificial delay to simulate quantum computation\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  \n  const timestamp = Date.now();\n  const entropy = new Uint8Array(32);\n  crypto.getRandomValues(entropy);\n  \n  return `QS-${principal.toText()}-${coherence.toFixed(6)}-${timestamp}-${Array.from(entropy.slice(0, 8))\n    .map(b => b.toString(16).padStart(2, '0')).join('')}`;\n}"],"names":["DimensionalStateImpl","baseResonance","alignmentFactor","entropyModifier","coherenceBoost","temporalFactor","quantumEffect","baseEntropy","quantumEntropy","baseBoost","resonanceBoost","timeDelta","dilationFactor","interactionStrength","timeBonus","effectiveStrength","timePassed","degradationFactor","baseDegradation","quantumFactor","entropyIncrease","baseMetrics","quantumInfluence","metric","metrics","avgMetric","a","b","entropyFactor","effectiveMetric","pattern","timeDecay","coherenceCheck","frequencyMatch","useQuantumState","identity","useAuth","consciousness","isConsciousnessInitialized","useConsciousness","initializationAttempted","useRef","initializationError","setInitializationError","useState","isInitializing","setIsInitializing","initializationTimeoutRef","state","setState","useEffect","prev","principal","principalArray","initialCoherence","acc","byte","consciousnessBoost","adjustedCoherence","dimensionalState","quantumSignature","generateQuantumSignature","resonancePatterns","_","i","error","intervalId","minCoherence","newCoherence","updatedPatterns","useCallback","updates","coherence","resolve","timestamp","entropy"],"mappings":"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"}