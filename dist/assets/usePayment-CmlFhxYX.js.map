{"version":3,"file":"usePayment-CmlFhxYX.js","sources":["../../src/hooks/usePayment.ts"],"sourcesContent":["import { useState, useCallback } from 'react';\nimport { useAuth } from '@/contexts/auth-context';\nimport { useQuantumState } from '@/hooks/useQuantumState';\nimport { Principal } from '@dfinity/principal';\nimport { PaymentResult, PaymentVerification, PaymentParams, TransactionReceipt, QuantumSignedReceipt } from '../types/payment';\nimport { ErrorTracker } from '../error/quantum_error';\n\nconst PAYMENT_AMOUNTS = {\n  Genesis: BigInt(100_000_000), // 1 ICP\n  Evolution: BigInt(50_000_000), // 0.5 ICP\n  Feature: BigInt(25_000_000),  // 0.25 ICP\n  Quantum: BigInt(75_000_000),  // 0.75 ICP\n};\n\nconst VERIFICATION_RETRIES = 3;\nconst VERIFICATION_INTERVAL = 2000;\nconst BALANCE_BUFFER = BigInt(10_000_000); // 0.1 ICP safety buffer\n\nexport const usePayment = () => {\n  const { actor, principal } = useAuth();\n  const { quantumState, updateQuantumState } = useQuantumState();\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [lastTransaction, setLastTransaction] = useState<PaymentResult | null>(null);\n  const [transactionReceipts] = useState<Map<string, TransactionReceipt>>(new Map());\n\n  const generateQuantumSignature = useCallback(async (transaction: PaymentResult): Promise<QuantumSignedReceipt> => {\n    if (!quantumState) throw new Error('Quantum state not initialized');\n\n    const quantumSignature = {\n      resonance: quantumState.resonance,\n      coherence: quantumState.coherenceLevel,\n      timestamp: Date.now(),\n      transactionHash: `${transaction.height}-${Date.now()}-${Math.random()}`\n    };\n\n    return {\n      ...transaction,\n      quantum: quantumSignature,\n      verified: true,\n      timestamp: BigInt(Date.now())\n    };\n  }, [quantumState]);\n\n  const validateBalance = useCallback(async (amount: bigint): Promise<boolean> => {\n    try {\n      const balance = await getBalance();\n      const requiredAmount = amount + BALANCE_BUFFER;\n      \n      if (balance < requiredAmount) {\n        throw new Error(`Insufficient balance. Need ${Number(requiredAmount) / 100_000_000} ICP (including buffer)`);\n      }\n\n      const stateValid = await validateQuantumState();\n      if (!stateValid) {\n        throw new Error('Quantum state unstable for transaction');\n      }\n\n      return true;\n    } catch (error) {\n      throw error;\n    }\n  }, []);\n\n  const validateQuantumState = useCallback(async (): Promise<boolean> => {\n    if (!quantumState) return false;\n    \n    const minCoherence = 0.7;\n    const minResonance = 0.6;\n\n    return quantumState.coherenceLevel >= minCoherence && \n           quantumState.resonance >= minResonance;\n  }, [quantumState]);\n\n  const getBalance = useCallback(async (): Promise<bigint> => {\n    if (!actor || !principal) {\n      throw new Error('Not authenticated');\n    }\n\n    try {\n      const balance = await actor.icrc1_balance_of({\n        owner: Principal.fromText(principal),\n        subaccount: [],\n      });\n      return balance;\n    } catch (err) {\n      console.error('Balance check failed:', err);\n      throw new Error('Failed to fetch balance');\n    }\n  }, [actor, principal]);\n\n  const initiatePayment = useCallback(async ({\n    amount,\n    memo = BigInt(Date.now()),\n    toCanister\n  }: PaymentParams): Promise<PaymentResult> => {\n    if (!actor || !principal) {\n      throw new Error('Not authenticated');\n    }\n\n    setIsProcessing(true);\n    setError(null);\n\n    try {\n      await validateBalance(amount);\n\n      const result = await actor.icrc2_transfer({\n        amount,\n        to: { owner: toCanister, subaccount: [] },\n        fee: [],\n        memo: [memo],\n        from_subaccount: [],\n        created_at_time: [BigInt(Date.now())],\n      });\n\n      if ('Err' in result) {\n        throw new Error(JSON.stringify(result.Err));\n      }\n\n      const payment: PaymentResult = {\n        height: result.Ok,\n        transactionId: result.Ok.toString(),\n      };\n\n      const signedReceipt = await generateQuantumSignature(payment);\n      transactionReceipts.set(payment.transactionId, signedReceipt);\n\n      setLastTransaction(payment);\n      return payment;\n\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Payment failed';\n      setError(errorMessage);\n      ErrorTracker.getInstance().trackError({\n        type: 'PAYMENT_ERROR',\n        message: errorMessage,\n        timestamp: Date.now(),\n        quantum: quantumState\n      });\n      throw new Error(errorMessage);\n    } finally {\n      setIsProcessing(false);\n    }\n  }, [actor, principal, validateBalance, generateQuantumSignature, quantumState]);\n\n  const verifyPayment = useCallback(async (height: bigint): Promise<PaymentVerification> => {\n    if (!actor) {\n      throw new Error('Not authenticated');\n    }\n\n    let retries = VERIFICATION_RETRIES;\n    \n    while (retries > 0) {\n      try {\n        const result = await actor.verify_payment(height);\n        \n        if ('Ok' in result) {\n          const quantumSignedResult = await generateQuantumSignature({\n            height,\n            transactionId: height.toString()\n          });\n\n          const verificationResult: PaymentVerification = {\n            verified: true,\n            timestamp: result.Ok.timestamp,\n            status: 'confirmed',\n            quantumSignature: quantumSignedResult.quantum\n          };\n\n          return verificationResult;\n        }\n\n        if (retries === 1) {\n          return {\n            verified: false,\n            timestamp: BigInt(Date.now()),\n            status: 'failed',\n            quantumSignature: null\n          };\n        }\n\n        await new Promise(resolve => setTimeout(resolve, VERIFICATION_INTERVAL));\n        retries--;\n        \n      } catch (err) {\n        if (retries === 1) {\n          throw new Error('Payment verification failed');\n        }\n        await new Promise(resolve => setTimeout(resolve, VERIFICATION_INTERVAL));\n        retries--;\n      }\n    }\n\n    return {\n      verified: false,\n      timestamp: BigInt(Date.now()),\n      status: 'failed',\n      quantumSignature: null\n    };\n  }, [actor, generateQuantumSignature]);\n\n  const getTransactionReceipt = useCallback((transactionId: string): TransactionReceipt | undefined => {\n    return transactionReceipts.get(transactionId);\n  }, [transactionReceipts]);\n\n  const getPaymentAmount = useCallback((type: keyof typeof PAYMENT_AMOUNTS) => {\n    return PAYMENT_AMOUNTS[type];\n  }, []);\n\n  const getTransactionStatus = useCallback(async (transactionId: string) => {\n    if (!actor) {\n      throw new Error('Not authenticated');\n    }\n\n    try {\n      const status = await actor.get_transaction_status(transactionId);\n      const receipt = transactionReceipts.get(transactionId);\n      \n      return {\n        ...status,\n        receipt,\n        quantumVerified: receipt?.quantum ? true : false\n      };\n    } catch (err) {\n      console.error('Failed to get transaction status:', err);\n      throw new Error('Transaction status check failed');\n    }\n  }, [actor]);\n\n  return {\n    initiatePayment,\n    verifyPayment,\n    getBalance,\n    getPaymentAmount,\n    getTransactionStatus,\n    getTransactionReceipt,\n    isProcessing,\n    error,\n    lastTransaction,\n  };\n};\n\nexport type PaymentHook = ReturnType<typeof usePayment>;"],"names":["PAYMENT_AMOUNTS","VERIFICATION_RETRIES","VERIFICATION_INTERVAL","BALANCE_BUFFER","usePayment","actor","principal","useAuth","quantumState","updateQuantumState","useQuantumState","isProcessing","setIsProcessing","useState","error","setError","lastTransaction","setLastTransaction","transactionReceipts","generateQuantumSignature","useCallback","transaction","quantumSignature","validateBalance","amount","balance","getBalance","requiredAmount","validateQuantumState","Principal","err","initiatePayment","memo","toCanister","result","payment","signedReceipt","errorMessage","ErrorTracker","verifyPayment","height","retries","quantumSignedResult","resolve","getTransactionReceipt","transactionId","getPaymentAmount","type","getTransactionStatus","status","receipt"],"mappings":"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"}