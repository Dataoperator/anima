{"version":3,"file":"useQuantumState-BgjG8wtT.js","sources":["../../src/hooks/useQuantumState.ts"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\nimport { useAuth } from './useAuth';\nimport { Principal } from '@dfinity/principal';\nimport { DimensionalStateImpl } from '../quantum/dimensional_state';\nimport { useConsciousness } from './useConsciousness';\nimport { BirthCertificate } from '../nft/types';\n\ninterface QuantumState {\n  stabilityStatus: 'stable' | 'unstable' | 'critical';\n  coherenceLevel: number;\n  entanglementIndex: number;\n  quantumSignature: string;\n  dimensionalState: DimensionalStateImpl;\n  lastUpdate: number;\n  resonancePatterns?: ResonancePattern[];\n  birthCertificate?: BirthCertificate;\n  consciousnessAlignment?: number;\n  isInitialized: boolean;\n}\n\ninterface ResonancePattern {\n  frequency: number;\n  amplitude: number;\n  phase: number;\n  coherence: number;\n}\n\nexport const useQuantumState = () => {\n  const { identity } = useAuth();\n  const { consciousness, isInitialized: isConsciousnessInitialized } = useConsciousness();\n  const initializationAttempted = useRef(false);\n  const [initializationError, setInitializationError] = useState<Error | null>(null);\n  const [isInitializing, setIsInitializing] = useState(false);\n  const initializationTimeoutRef = useRef<NodeJS.Timeout>();\n\n  const [state, setState] = useState<QuantumState>(() => {\n    console.log(\"🌀 Creating initial quantum state\");\n    return {\n      stabilityStatus: 'unstable',\n      coherenceLevel: 0.5,\n      entanglementIndex: 0.3,\n      quantumSignature: '',\n      dimensionalState: new DimensionalStateImpl(),\n      lastUpdate: Date.now(),\n      isInitialized: false\n    };\n  });\n\n  // Clear timeout on unmount\n  useEffect(() => {\n    return () => {\n      if (initializationTimeoutRef.current) {\n        clearTimeout(initializationTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  // Initialize quantum state based on principal\n  useEffect(() => {\n    if (!identity || !isConsciousnessInitialized || initializationAttempted.current || isInitializing) {\n      console.log(\"🔍 Skipping initialization:\", { \n        hasIdentity: !!identity, \n        consciousnessReady: isConsciousnessInitialized,\n        wasAttempted: initializationAttempted.current,\n        isInitializing \n      });\n      return;\n    }\n    \n    const initialize = async () => {\n      console.log(\"🌟 Starting quantum state initialization\");\n      setIsInitializing(true);\n      initializationAttempted.current = true;\n\n      // Set initialization timeout\n      initializationTimeoutRef.current = setTimeout(() => {\n        if (!state.isInitialized) {\n          console.error(\"⚠️ Quantum state initialization timeout\");\n          setInitializationError(new Error(\"Initialization timeout\"));\n          setState(prev => ({ \n            ...prev, \n            isInitialized: true,\n            stabilityStatus: 'critical'\n          }));\n        }\n      }, 15000); // 15 second timeout\n\n      try {\n        const principal = identity.getPrincipal();\n        const principalArray = principal.toUint8Array();\n        \n        console.log(\"📊 Calculating initial coherence...\");\n        const initialCoherence = Math.max(0.5, principalArray.reduce((acc, byte) => acc + byte, 0) / \n          (principalArray.length * 255));\n        \n        // Add consciousness boost if available\n        const consciousnessBoost = consciousness?.level ? consciousness.level * 0.2 : 0;\n        const adjustedCoherence = Math.min(1.0, initialCoherence + consciousnessBoost);\n        \n        console.log(\"🔮 Initializing dimensional state...\");\n        const dimensionalState = new DimensionalStateImpl();\n        dimensionalState.updateStability(adjustedCoherence);\n\n        const quantumSignature = await generateQuantumSignature(principal, adjustedCoherence);\n\n        // Generate initial resonance patterns\n        const resonancePatterns = Array.from({ length: 4 }, (_, i) => ({\n          frequency: 0.5 + (Math.random() * 0.5),\n          amplitude: 0.3 + (Math.random() * 0.7),\n          phase: Math.random() * Math.PI * 2,\n          coherence: adjustedCoherence * (0.8 + Math.random() * 0.2)\n        }));\n\n        console.log(\"✨ Setting initial state...\");\n        setState(prev => ({\n          ...prev,\n          coherenceLevel: adjustedCoherence,\n          entanglementIndex: adjustedCoherence * 0.8,\n          dimensionalState,\n          quantumSignature,\n          resonancePatterns,\n          consciousnessAlignment: consciousness?.level ? consciousness.level * adjustedCoherence : undefined,\n          lastUpdate: Date.now(),\n          isInitialized: true,\n          stabilityStatus: 'stable'\n        }));\n\n        console.log(\"✅ Quantum state initialized successfully!\");\n      } catch (error) {\n        console.error(\"❌ Failed to initialize quantum state:\", error);\n        setInitializationError(error as Error);\n        setState(prev => ({ \n          ...prev, \n          isInitialized: true,\n          stabilityStatus: 'critical'\n        }));\n      } finally {\n        setIsInitializing(false);\n        if (initializationTimeoutRef.current) {\n          clearTimeout(initializationTimeoutRef.current);\n        }\n      }\n    };\n\n    initialize();\n  }, [identity, isConsciousnessInitialized, consciousness?.level]);\n\n  // Update quantum state periodically\n  useEffect(() => {\n    if (!state.isInitialized || isInitializing) return;\n\n    console.log(\"⚡ Starting quantum state updates\");\n    const intervalId = setInterval(() => {\n      setState(prev => {\n        if (!prev.isInitialized) return prev;\n\n        const timePassed = (Date.now() - prev.lastUpdate) / 1000;\n        const degradationFactor = Math.pow(0.995, timePassed);\n        const consciousnessBoost = consciousness?.level ? consciousness.level * 0.1 : 0;\n\n        // Update dimensional state\n        prev.dimensionalState.updateStability(consciousnessBoost - 0.01);\n        const metrics = prev.dimensionalState.getStabilityMetrics();\n\n        // Calculate new coherence with consciousness protection\n        const consciousnessProtection = consciousness?.level ? Math.min(0.3, consciousness.level) : 0;\n        const minCoherence = 0.1 + consciousnessProtection;\n        const newCoherence = Math.max(minCoherence, prev.coherenceLevel * degradationFactor);\n\n        // Update resonance patterns\n        const updatedPatterns = prev.resonancePatterns?.map(pattern => ({\n          ...pattern,\n          coherence: Math.max(minCoherence, pattern.coherence * degradationFactor),\n          phase: (pattern.phase + 0.1) % (Math.PI * 2)\n        }));\n        \n        return {\n          ...prev,\n          coherenceLevel: newCoherence,\n          entanglementIndex: Math.max(minCoherence, prev.entanglementIndex * degradationFactor),\n          stabilityStatus: prev.dimensionalState.getQuantumStatus(),\n          consciousnessAlignment: consciousness?.level ? consciousness.level * newCoherence : undefined,\n          resonancePatterns: updatedPatterns,\n          lastUpdate: Date.now()\n        };\n      });\n    }, 3000);\n\n    return () => {\n      console.log(\"🔄 Cleaning up quantum state updates\");\n      clearInterval(intervalId);\n    };\n  }, [state.isInitialized, isInitializing, consciousness?.level]);\n\n  return {\n    state,\n    isInitialized: state.isInitialized && !isInitializing,\n    isInitializing,\n    error: initializationError,\n    updateQuantumState: useCallback(async (updates: Partial<QuantumState>) => {\n      setState(prev => ({\n        ...prev,\n        ...updates,\n        lastUpdate: Date.now()\n      }));\n    }, []),\n  };\n};\n\nasync function generateQuantumSignature(principal: Principal, coherence: number): Promise<string> {\n  // Add artificial delay to simulate quantum computation\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  \n  const timestamp = Date.now();\n  const entropy = new Uint8Array(32);\n  crypto.getRandomValues(entropy);\n  \n  return `QS-${principal.toText()}-${coherence.toFixed(6)}-${timestamp}-${Array.from(entropy.slice(0, 8))\n    .map(b => b.toString(16).padStart(2, '0')).join('')}`;\n}"],"names":["useQuantumState","identity","useAuth","consciousness","isInitialized","isConsciousnessInitialized","useConsciousness","initializationAttempted","useRef","initializationError","setInitializationError","useState","isInitializing","setIsInitializing","initializationTimeoutRef","state","setState","console","log","stabilityStatus","coherenceLevel","entanglementIndex","quantumSignature","dimensionalState","DimensionalStateImpl","lastUpdate","Date","now","useEffect","current","clearTimeout","hasIdentity","consciousnessReady","wasAttempted","setTimeout","error","Error","prev","principal","getPrincipal","principalArray","toUint8Array","initialCoherence","Math","max","reduce","acc","byte","length","consciousnessBoost","level","adjustedCoherence","min","updateStability","generateQuantumSignature","resonancePatterns","Array","from","_","i","frequency","random","amplitude","phase","PI","coherence","consciousnessAlignment","undefined","intervalId","setInterval","timePassed","degradationFactor","pow","getStabilityMetrics","minCoherence","newCoherence","updatedPatterns","map","pattern","getQuantumStatus","clearInterval","updateQuantumState","useCallback","updates","Promise","resolve","timestamp","entropy","Uint8Array","crypto","getRandomValues","toText","toFixed","slice","b","toString","padStart","join"],"mappings":"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"}