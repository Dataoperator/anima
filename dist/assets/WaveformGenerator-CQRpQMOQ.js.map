{"version":3,"file":"WaveformGenerator-CQRpQMOQ.js","sources":["../../src/hooks/useAnima.js","../../src/hooks/useActor.ts","../../src/hooks/useQuantumState.js","../../src/components/personality/WaveformGenerator.tsx"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\nimport { useAuth } from './useAuth';\n\nexport const useAnima = () => {\n  const { identity, actor } = useAuth();\n  const [animas, setAnimas] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [activeAnima, setActiveAnima] = useState(null);\n\n  const fetchUserAnimas = useCallback(async () => {\n    if (!actor || !identity) return;\n    \n    try {\n      setLoading(true);\n      const principal = identity.getPrincipal();\n      const userAnimas = await actor.get_user_animas(principal);\n      setAnimas(userAnimas);\n      return userAnimas;\n    } catch (err) {\n      console.error('Error fetching animas:', err);\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  }, [actor, identity]);\n\n  const getAnima = useCallback(async (id) => {\n    if (!actor) return null;\n    \n    try {\n      const anima = await actor.get_anima(id);\n      setActiveAnima(anima);\n      return anima;\n    } catch (err) {\n      console.error('Error fetching anima:', err);\n      setError(err.message);\n      return null;\n    }\n  }, [actor]);\n\n  const createAnima = useCallback(async () => {\n    if (!actor || !identity) return null;\n    \n    try {\n      setLoading(true);\n      const anima = await actor.create_anima();\n      await fetchUserAnimas(); // Refresh list\n      return anima;\n    } catch (err) {\n      console.error('Error creating anima:', err);\n      setError(err.message);\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [actor, identity, fetchUserAnimas]);\n\n  useEffect(() => {\n    fetchUserAnimas();\n  }, [fetchUserAnimas]);\n\n  return {\n    animas,\n    activeAnima,\n    loading,\n    error,\n    fetchUserAnimas,\n    getAnima,\n    createAnima,\n    actor\n  };\n};","import { useCallback } from 'react';\nimport { Actor, HttpAgent } from '@dfinity/agent';\nimport { useAuth } from './useAuth';\nimport { canisterId, createActor } from '../declarations/anima';\n\nexport const useActor = () => {\n  const { identity } = useAuth();\n\n  const getActor = useCallback(async () => {\n    if (!identity) {\n      throw new Error('No identity available');\n    }\n\n    const agent = new HttpAgent({ identity });\n\n    // Only fetch root key in development\n    if (process.env.NODE_ENV !== 'production') {\n      await agent.fetchRootKey();\n    }\n\n    return createActor(canisterId, {\n      agent,\n    });\n  }, [identity]);\n\n  return {\n    getActor,\n  };\n};\n\nexport default useActor;","import { useState, useCallback, useContext } from 'react';\nimport { useActor } from './useActor';\nimport { toast } from '@/components/ui/use-toast';\n\nexport const useQuantumState = (animaId) => {\n  const [isObserving, setIsObserving] = useState(false);\n  const [isEntangling, setIsEntangling] = useState(false);\n  const actor = useActor();\n\n  const observeState = useCallback(async () => {\n    if (!actor || !animaId) return null;\n    setIsObserving(true);\n    \n    try {\n      const state = await actor.observe_quantum_state(animaId);\n      return state;\n    } catch (error) {\n      toast({\n        title: \"Quantum Observation Failed\",\n        description: \"The quantum state collapsed during observation.\",\n        variant: \"destructive\",\n      });\n      return null;\n    } finally {\n      setIsObserving(false);\n    }\n  }, [actor, animaId]);\n\n  const initiateEntanglement = useCallback(async (targetId) => {\n    if (!actor || !animaId) return false;\n    setIsEntangling(true);\n    \n    try {\n      const result = await actor.attempt_quantum_entanglement(animaId, targetId);\n      \n      if ('Ok' in result) {\n        toast({\n          title: \"Quantum Entanglement Successful\",\n          description: \"A new quantum connection has been established.\",\n        });\n        return true;\n      } else {\n        toast({\n          title: \"Entanglement Failed\",\n          description: \"Unable to establish quantum connection.\",\n          variant: \"destructive\",\n        });\n        return false;\n      }\n    } catch (error) {\n      toast({\n        title: \"Entanglement Error\",\n        description: \"An unexpected error occurred during entanglement.\",\n        variant: \"destructive\",\n      });\n      return false;\n    } finally {\n      setIsEntangling(false);\n    }\n  }, [actor, animaId]);\n\n  const getMetrics = useCallback(async () => {\n    if (!actor || !animaId) return null;\n    \n    try {\n      const metrics = await actor.get_quantum_metrics(animaId);\n      return metrics;\n    } catch (error) {\n      console.error('Failed to fetch quantum metrics:', error);\n      return null;\n    }\n  }, [actor, animaId]);\n\n  return {\n    observeState,\n    initiateEntanglement,\n    getMetrics,\n    isObserving,\n    isEntangling,\n  };\n};\n","import React, { useRef, useEffect } from 'react';\n\ntype WaveformProps = {\n  type: 'Stable' | 'Fluctuating' | 'Entangled';\n  amplitude: number;\n  frequency: number;\n  className?: string;\n};\n\nexport const WaveformGenerator: React.FC<WaveformProps> = ({\n  type,\n  amplitude,\n  frequency,\n  className = ''\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  useEffect(() => {\n    if (!canvasRef.current) return;\n\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Set up animation\n    let animationFrameId: number;\n    let time = 0;\n\n    const render = () => {\n      if (!canvas || !ctx) return;\n\n      // Clear canvas\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      // Set line style\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = type === 'Entangled' \n        ? '#FF61DC' // quantum-pink\n        : '#7B61FF'; // quantum-purple\n\n      // Start drawing path\n      ctx.beginPath();\n      ctx.moveTo(0, canvas.height / 2);\n\n      // Generate waveform based on type\n      for (let x = 0; x < canvas.width; x++) {\n        let y = canvas.height / 2;\n\n        switch (type) {\n          case 'Stable':\n            // Straight line with slight noise\n            y += Math.random() * 2 - 1;\n            break;\n\n          case 'Fluctuating':\n            // Sine wave with varying amplitude\n            y += Math.sin(x * frequency + time) * \n                 amplitude * (canvas.height / 4);\n            break;\n\n          case 'Entangled':\n            // Double sine wave with phase relationship\n            const wave1 = Math.sin(x * frequency + time) * \n                         amplitude * (canvas.height / 6);\n            const wave2 = Math.sin(x * frequency + time + Math.PI) * \n                         amplitude * (canvas.height / 6);\n            y += (wave1 + wave2) / 2;\n            break;\n        }\n\n        ctx.lineTo(x, y);\n      }\n\n      // Stroke the path\n      ctx.stroke();\n\n      // Update time for animation\n      time += 0.05;\n\n      // Request next frame\n      animationFrameId = requestAnimationFrame(render);\n    };\n\n    render();\n\n    return () => {\n      cancelAnimationFrame(animationFrameId);\n    };\n  }, [type, amplitude, frequency]);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      className={`w-full h-full ${className}`}\n      style={{\n        filter: type === 'Entangled' \n          ? 'drop-shadow(0 0 8px rgba(255, 97, 220, 0.3))' \n          : 'drop-shadow(0 0 8px rgba(123, 97, 255, 0.3))'\n      }}\n    />\n  );\n};"],"names":["useAnima","identity","actor","useAuth","animas","setAnimas","useState","loading","setLoading","error","setError","activeAnima","setActiveAnima","fetchUserAnimas","useCallback","principal","getPrincipal","userAnimas","get_user_animas","err","console","message","getAnima","id","anima","get_anima","createAnima","create_anima","useEffect","useActor","getActor","Error","agent","HttpAgent","createActor","canisterId","useQuantumState","animaId","isObserving","setIsObserving","isEntangling","setIsEntangling","observeState","initiateEntanglement","targetId","getMetrics","WaveformGenerator","type","amplitude","frequency","className","canvasRef","useRef","current","canvas","ctx","getContext","animationFrameId","time","render","clearRect","width","height","lineWidth","strokeStyle","beginPath","moveTo","x","y","Math","random","sin","wave1","wave2","PI","lineTo","stroke","requestAnimationFrame","cancelAnimationFrame","ref","style","filter"],"mappings":"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"}