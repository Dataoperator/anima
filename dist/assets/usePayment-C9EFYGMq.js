import{b as C,c as P,r as n,P as v,E as N}from"./index-BGLOSt1o.js";const _={Genesis:BigInt(1e8),Evolution:BigInt(5e7),Feature:BigInt(25e6),Quantum:BigInt(75e6)},q=3,h=2e3,A=BigInt(1e7),F=()=>{const{actor:r,principal:c}=C(),{quantumState:i,updateQuantumState:O}=P(),[d,m]=n.useState(!1),[E,f]=n.useState(null),[y,I]=n.useState(null),[u]=n.useState(new Map),l=n.useCallback(async t=>{if(!i)throw new Error("Quantum state not initialized");const e={resonance:i.resonance,coherence:i.coherenceLevel,timestamp:Date.now(),transactionHash:`${t.height}-${Date.now()}-${Math.random()}`};return{...t,quantum:e,verified:!0,timestamp:BigInt(Date.now())}},[i]),w=n.useCallback(async t=>{try{const e=await g(),s=t+A;if(e<s)throw new Error(`Insufficient balance. Need ${Number(s)/1e8} ICP (including buffer)`);if(!await b())throw new Error("Quantum state unstable for transaction");return!0}catch(e){throw e}},[]),b=n.useCallback(async()=>i?i.coherenceLevel>=.7&&i.resonance>=.6:!1,[i]),g=n.useCallback(async()=>{if(!r||!c)throw new Error("Not authenticated");try{return await r.icrc1_balance_of({owner:v.fromText(c),subaccount:[]})}catch(t){throw console.error("Balance check failed:",t),new Error("Failed to fetch balance")}},[r,c]),p=n.useCallback(async({amount:t,memo:e=BigInt(Date.now()),toCanister:s})=>{if(!r||!c)throw new Error("Not authenticated");m(!0),f(null);try{await w(t);const a=await r.icrc2_transfer({amount:t,to:{owner:s,subaccount:[]},fee:[],memo:[e],from_subaccount:[],created_at_time:[BigInt(Date.now())]});if("Err"in a)throw new Error(JSON.stringify(a.Err));const o={height:a.Ok,transactionId:a.Ok.toString()},B=await l(o);return u.set(o.transactionId,B),I(o),o}catch(a){const o=a instanceof Error?a.message:"Payment failed";throw f(o),N.getInstance().trackError({type:"PAYMENT_ERROR",message:o,timestamp:Date.now(),quantum:i}),new Error(o)}finally{m(!1)}},[r,c,w,l,i]),S=n.useCallback(async t=>{if(!r)throw new Error("Not authenticated");let e=q;for(;e>0;)try{const s=await r.verify_payment(t);if("Ok"in s){const a=await l({height:t,transactionId:t.toString()});return{verified:!0,timestamp:s.Ok.timestamp,status:"confirmed",quantumSignature:a.quantum}}if(e===1)return{verified:!1,timestamp:BigInt(Date.now()),status:"failed",quantumSignature:null};await new Promise(a=>setTimeout(a,h)),e--}catch{if(e===1)throw new Error("Payment verification failed");await new Promise(a=>setTimeout(a,h)),e--}return{verified:!1,timestamp:BigInt(Date.now()),status:"failed",quantumSignature:null}},[r,l]),k=n.useCallback(t=>u.get(t),[u]),R=n.useCallback(t=>_[t],[]),T=n.useCallback(async t=>{if(!r)throw new Error("Not authenticated");try{const e=await r.get_transaction_status(t),s=u.get(t);return{...e,receipt:s,quantumVerified:!!s?.quantum}}catch(e){throw console.error("Failed to get transaction status:",e),new Error("Transaction status check failed")}},[r]);return{initiatePayment:p,verifyPayment:S,getBalance:g,getPaymentAmount:R,getTransactionStatus:T,getTransactionReceipt:k,isProcessing:d,error:E,lastTransaction:y}};export{F as u};
//# sourceMappingURL=usePayment-C9EFYGMq.js.map
