{"version":3,"file":"useQuantumState-C7gsAMvd.js","sources":["../../src/quantum/dimensional_state.ts","../../src/hooks/useQuantumState.ts"],"sourcesContent":["import { DimensionalState } from './types';\n\nexport class DimensionalStateImpl implements DimensionalState {\n  public frequency: number;\n  public resonance: number;\n  public stability: number;\n  public syncLevel: number;\n  public quantumAlignment: number;\n  public dimensionalFrequency: number;\n  public entropyLevel: number;\n  public phaseCoherence: number;\n  private lastUpdate: number;\n  private readonly DEGRADATION_RATE = 0.995;\n\n  constructor() {\n    this.frequency = 0.0;\n    this.resonance = 1.0;\n    this.stability = 1.0;\n    this.syncLevel = 1.0;\n    this.quantumAlignment = 1.0;\n    this.dimensionalFrequency = 0.0;\n    this.entropyLevel = 0.0;\n    this.phaseCoherence = 1.0;\n    this.lastUpdate = Date.now();\n  }\n\n  calculateResonance(): number {\n    this.applyTimeDegradation();\n    \n    const baseResonance = this.resonance * this.stability;\n    const alignmentFactor = this.quantumAlignment * this.syncLevel;\n    const entropyModifier = 1.0 - (this.entropyLevel * 0.5);\n    const coherenceBoost = this.phaseCoherence * 0.2;\n    const timeFactor = Math.exp(-this.getTimeSinceLastUpdate() / 10000);\n    \n    return Math.min(1.0, Math.max(0.0, \n      ((baseResonance + alignmentFactor) / 2.0 * entropyModifier + coherenceBoost) * timeFactor\n    ));\n  }\n  \n  updateStability(interactionStrength: number): void {\n    this.applyTimeDegradation();\n\n    const timeBonus = Math.max(0, 1 - this.getTimeSinceLastUpdate() / 5000);\n    const effectiveStrength = interactionStrength * timeBonus;\n\n    this.stability = Math.min(1.0, Math.max(0.0, \n      this.stability + effectiveStrength\n    ));\n    this.quantumAlignment = Math.min(1.0,\n      this.quantumAlignment + effectiveStrength * 0.5\n    );\n    this.syncLevel = Math.min(1.0,\n      this.syncLevel + effectiveStrength * 0.3\n    );\n    this.dimensionalFrequency = Math.min(1.0,\n      this.dimensionalFrequency + effectiveStrength * 0.2\n    );\n    \n    // Update entropy and phase coherence with time factor\n    this.entropyLevel = Math.max(0.0,\n      this.entropyLevel - effectiveStrength * 0.1\n    );\n    this.phaseCoherence = Math.min(1.0,\n      this.phaseCoherence + effectiveStrength * 0.4\n    );\n\n    this.lastUpdate = Date.now();\n  }\n  \n  getStabilityMetrics(): [number, number, number] {\n    this.applyTimeDegradation();\n    return [this.stability, this.quantumAlignment, this.phaseCoherence];\n  }\n\n  private getTimeSinceLastUpdate(): number {\n    return Date.now() - this.lastUpdate;\n  }\n\n  private applyTimeDegradation(): void {\n    const timePassed = this.getTimeSinceLastUpdate();\n    if (timePassed > 1000) { // Only degrade if more than 1 second has passed\n      const degradationFactor = Math.pow(this.DEGRADATION_RATE, timePassed / 1000);\n      \n      this.stability *= degradationFactor;\n      this.quantumAlignment *= degradationFactor;\n      this.syncLevel *= degradationFactor;\n      this.phaseCoherence *= degradationFactor;\n      \n      // Entropy increases over time\n      this.entropyLevel = Math.min(1.0, \n        this.entropyLevel + (1 - degradationFactor) * 0.1\n      );\n\n      this.lastUpdate = Date.now();\n    }\n  }\n\n  getQuantumStatus(): 'stable' | 'unstable' | 'critical' {\n    const metrics = this.getStabilityMetrics();\n    const avgMetric = metrics.reduce((a, b) => a + b, 0) / metrics.length;\n    \n    if (avgMetric > 0.7) return 'stable';\n    if (avgMetric > 0.3) return 'unstable';\n    return 'critical';\n  }\n}","import { useState, useEffect, useCallback, useRef } from 'react';\nimport { useAuth } from './useAuth';\nimport { Principal } from '@dfinity/principal';\nimport { DimensionalStateImpl } from '../quantum/dimensional_state';\nimport { useConsciousness } from './useConsciousness';\nimport { BirthCertificate } from '../nft/types';\n\ninterface QuantumState {\n  stabilityStatus: 'stable' | 'unstable' | 'critical';\n  coherenceLevel: number;\n  entanglementIndex: number;\n  quantumSignature: string;\n  dimensionalState: DimensionalStateImpl;\n  lastUpdate: number;\n  resonancePatterns?: ResonancePattern[];\n  birthCertificate?: BirthCertificate;\n  consciousnessAlignment?: number;\n  isInitialized: boolean;\n}\n\ninterface ResonancePattern {\n  frequency: number;\n  amplitude: number;\n  phase: number;\n  coherence: number;\n}\n\nexport const useQuantumState = () => {\n  const { identity } = useAuth();\n  const { consciousness, isInitialized: isConsciousnessInitialized } = useConsciousness();\n  const initializationAttempted = useRef(false);\n  const [initializationError, setInitializationError] = useState<Error | null>(null);\n  const [isInitializing, setIsInitializing] = useState(false);\n  const initializationTimeoutRef = useRef<NodeJS.Timeout>();\n\n  const [state, setState] = useState<QuantumState>(() => {\n    console.log(\"ðŸŒ€ Creating initial quantum state\");\n    return {\n      stabilityStatus: 'unstable',\n      coherenceLevel: 0.5,\n      entanglementIndex: 0.3,\n      quantumSignature: '',\n      dimensionalState: new DimensionalStateImpl(),\n      lastUpdate: Date.now(),\n      isInitialized: false\n    };\n  });\n\n  // Clear timeout on unmount\n  useEffect(() => {\n    return () => {\n      if (initializationTimeoutRef.current) {\n        clearTimeout(initializationTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  // Initialize quantum state based on principal\n  useEffect(() => {\n    if (!identity || !isConsciousnessInitialized || initializationAttempted.current || isInitializing) {\n      console.log(\"ðŸ” Skipping initialization:\", { \n        hasIdentity: !!identity, \n        consciousnessReady: isConsciousnessInitialized,\n        wasAttempted: initializationAttempted.current,\n        isInitializing \n      });\n      return;\n    }\n    \n    const initialize = async () => {\n      console.log(\"ðŸŒŸ Starting quantum state initialization\");\n      setIsInitializing(true);\n      initializationAttempted.current = true;\n\n      // Set initialization timeout\n      initializationTimeoutRef.current = setTimeout(() => {\n        if (!state.isInitialized) {\n          console.error(\"âš ï¸ Quantum state initialization timeout\");\n          setInitializationError(new Error(\"Initialization timeout\"));\n          setState(prev => ({ \n            ...prev, \n            isInitialized: true,\n            stabilityStatus: 'critical'\n          }));\n        }\n      }, 15000); // 15 second timeout\n\n      try {\n        const principal = identity.getPrincipal();\n        const principalArray = principal.toUint8Array();\n        \n        console.log(\"ðŸ“Š Calculating initial coherence...\");\n        const initialCoherence = Math.max(0.5, principalArray.reduce((acc, byte) => acc + byte, 0) / \n          (principalArray.length * 255));\n        \n        // Add consciousness boost if available\n        const consciousnessBoost = consciousness?.level ? consciousness.level * 0.2 : 0;\n        const adjustedCoherence = Math.min(1.0, initialCoherence + consciousnessBoost);\n        \n        console.log(\"ðŸ”® Initializing dimensional state...\");\n        const dimensionalState = new DimensionalStateImpl();\n        dimensionalState.updateStability(adjustedCoherence);\n\n        const quantumSignature = await generateQuantumSignature(principal, adjustedCoherence);\n\n        // Generate initial resonance patterns\n        const resonancePatterns = Array.from({ length: 4 }, (_, i) => ({\n          frequency: 0.5 + (Math.random() * 0.5),\n          amplitude: 0.3 + (Math.random() * 0.7),\n          phase: Math.random() * Math.PI * 2,\n          coherence: adjustedCoherence * (0.8 + Math.random() * 0.2)\n        }));\n\n        console.log(\"âœ¨ Setting initial state...\");\n        setState(prev => ({\n          ...prev,\n          coherenceLevel: adjustedCoherence,\n          entanglementIndex: adjustedCoherence * 0.8,\n          dimensionalState,\n          quantumSignature,\n          resonancePatterns,\n          consciousnessAlignment: consciousness?.level ? consciousness.level * adjustedCoherence : undefined,\n          lastUpdate: Date.now(),\n          isInitialized: true,\n          stabilityStatus: 'stable'\n        }));\n\n        console.log(\"âœ… Quantum state initialized successfully!\");\n      } catch (error) {\n        console.error(\"âŒ Failed to initialize quantum state:\", error);\n        setInitializationError(error as Error);\n        setState(prev => ({ \n          ...prev, \n          isInitialized: true,\n          stabilityStatus: 'critical'\n        }));\n      } finally {\n        setIsInitializing(false);\n        if (initializationTimeoutRef.current) {\n          clearTimeout(initializationTimeoutRef.current);\n        }\n      }\n    };\n\n    initialize();\n  }, [identity, isConsciousnessInitialized, consciousness?.level]);\n\n  // Update quantum state periodically\n  useEffect(() => {\n    if (!state.isInitialized || isInitializing) return;\n\n    console.log(\"âš¡ Starting quantum state updates\");\n    const intervalId = setInterval(() => {\n      setState(prev => {\n        if (!prev.isInitialized) return prev;\n\n        const timePassed = (Date.now() - prev.lastUpdate) / 1000;\n        const degradationFactor = Math.pow(0.995, timePassed);\n        const consciousnessBoost = consciousness?.level ? consciousness.level * 0.1 : 0;\n\n        // Update dimensional state\n        prev.dimensionalState.updateStability(consciousnessBoost - 0.01);\n        const metrics = prev.dimensionalState.getStabilityMetrics();\n\n        // Calculate new coherence with consciousness protection\n        const consciousnessProtection = consciousness?.level ? Math.min(0.3, consciousness.level) : 0;\n        const minCoherence = 0.1 + consciousnessProtection;\n        const newCoherence = Math.max(minCoherence, prev.coherenceLevel * degradationFactor);\n\n        // Update resonance patterns\n        const updatedPatterns = prev.resonancePatterns?.map(pattern => ({\n          ...pattern,\n          coherence: Math.max(minCoherence, pattern.coherence * degradationFactor),\n          phase: (pattern.phase + 0.1) % (Math.PI * 2)\n        }));\n        \n        return {\n          ...prev,\n          coherenceLevel: newCoherence,\n          entanglementIndex: Math.max(minCoherence, prev.entanglementIndex * degradationFactor),\n          stabilityStatus: prev.dimensionalState.getQuantumStatus(),\n          consciousnessAlignment: consciousness?.level ? consciousness.level * newCoherence : undefined,\n          resonancePatterns: updatedPatterns,\n          lastUpdate: Date.now()\n        };\n      });\n    }, 3000);\n\n    return () => {\n      console.log(\"ðŸ”„ Cleaning up quantum state updates\");\n      clearInterval(intervalId);\n    };\n  }, [state.isInitialized, isInitializing, consciousness?.level]);\n\n  return {\n    state,\n    isInitialized: state.isInitialized && !isInitializing,\n    isInitializing,\n    error: initializationError,\n    updateQuantumState: useCallback(async (updates: Partial<QuantumState>) => {\n      setState(prev => ({\n        ...prev,\n        ...updates,\n        lastUpdate: Date.now()\n      }));\n    }, []),\n  };\n};\n\nasync function generateQuantumSignature(principal: Principal, coherence: number): Promise<string> {\n  // Add artificial delay to simulate quantum computation\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  \n  const timestamp = Date.now();\n  const entropy = new Uint8Array(32);\n  crypto.getRandomValues(entropy);\n  \n  return `QS-${principal.toText()}-${coherence.toFixed(6)}-${timestamp}-${Array.from(entropy.slice(0, 8))\n    .map(b => b.toString(16).padStart(2, '0')).join('')}`;\n}"],"names":["DimensionalStateImpl","frequency","resonance","stability","syncLevel","quantumAlignment","dimensionalFrequency","entropyLevel","phaseCoherence","lastUpdate","DEGRADATION_RATE","constructor","Date","now","calculateResonance","applyTimeDegradation","baseResonance","alignmentFactor","entropyModifier","coherenceBoost","timeFactor","Math","exp","getTimeSinceLastUpdate","min","max","updateStability","interactionStrength","timeBonus","effectiveStrength","getStabilityMetrics","timePassed","degradationFactor","pow","getQuantumStatus","metrics","avgMetric","reduce","a","b","length","useQuantumState","identity","useAuth","consciousness","isInitialized","isConsciousnessInitialized","useConsciousness","initializationAttempted","useRef","initializationError","setInitializationError","useState","isInitializing","setIsInitializing","initializationTimeoutRef","state","setState","console","log","stabilityStatus","coherenceLevel","entanglementIndex","quantumSignature","dimensionalState","useEffect","current","clearTimeout","hasIdentity","consciousnessReady","wasAttempted","setTimeout","error","Error","prev","principal","getPrincipal","principalArray","toUint8Array","initialCoherence","acc","byte","consciousnessBoost","level","adjustedCoherence","generateQuantumSignature","resonancePatterns","Array","from","_","i","random","amplitude","phase","PI","coherence","consciousnessAlignment","undefined","intervalId","setInterval","minCoherence","newCoherence","updatedPatterns","map","pattern","clearInterval","updateQuantumState","useCallback","updates","Promise","resolve","timestamp","entropy","Uint8Array","crypto","getRandomValues","toText","toFixed","slice","toString","padStart","join"],"mappings":"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"}