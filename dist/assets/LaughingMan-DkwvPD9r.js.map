{"version":3,"file":"LaughingMan-DkwvPD9r.js","sources":["../../src/contexts/anima-context.tsx","../../src/components/ui/LaughingMan.jsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';\nimport { useAuth } from './auth-context';\nimport { DimensionalStateImpl } from '@/quantum/dimensional_state';\nimport { MemorySystem } from '@/memory/memory';\nimport { GrowthSystem } from '@/growth/growth_system';\nimport { Memory } from '@/memory/types';\nimport { GrowthMetrics } from '@/growth/types';\nimport { Principal } from '@dfinity/principal';\nimport { useQuantumState } from '@/hooks/useQuantumState';\n\ninterface AnimaMintResult {\n  id: string;\n  quantumSignature: string;\n  timestamp: bigint;\n}\n\ninterface AnimaContextType {\n  dimensionalState: DimensionalStateImpl;\n  memorySystem: MemorySystem;\n  growthSystem: GrowthSystem;\n  quantumSignature: string;\n  evolutionFactor: number;\n  recentMemories: Memory[];\n  growthMetrics: GrowthMetrics;\n  isInitialized: boolean;\n  isMinting: boolean;\n  mintError: string | null;\n  isConnected: boolean;\n  processInteraction: (strength: number) => Promise<void>;\n  syncQuantumState: () => Promise<void>;\n  createMemory: (description: string, importance: number, keywords?: string[]) => void;\n  mintAnima: (name: string) => Promise<AnimaMintResult>;\n  createActor: () => any;\n  reconnect: () => Promise<void>;\n}\n\nconst AnimaContext = createContext<AnimaContextType | null>(null);\n\nexport function AnimaProvider({ children }: { children: React.ReactNode }) {\n  const { principal, actor } = useAuth();\n  const { quantumState, updateQuantumState, validateState } = useQuantumState();\n  const [dimensionalState] = useState(() => new DimensionalStateImpl());\n  const [memorySystem] = useState(() => new MemorySystem());\n  const [growthSystem] = useState(() => new GrowthSystem());\n  const [quantumSignature, setQuantumSignature] = useState('');\n  const [evolutionFactor, setEvolutionFactor] = useState(0);\n  const [recentMemories, setRecentMemories] = useState<Memory[]>([]);\n  const [growthMetrics, setGrowthMetrics] = useState<GrowthMetrics>(() => growthSystem.getMetrics());\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [isMinting, setIsMinting] = useState(false);\n  const [mintError, setMintError] = useState<string | null>(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [connectionAttempts, setConnectionAttempts] = useState(0);\n  const MAX_RECONNECT_ATTEMPTS = 3;\n\n  useEffect(() => {\n    if (quantumState && principal) {\n      initializeAnimaSystems();\n    }\n  }, [quantumState, principal]);\n\n  const initializeAnimaSystems = async () => {\n    try {\n      console.log('ðŸ§¬ Initializing ANIMA systems...');\n      \n      dimensionalState.quantumAlignment = quantumState?.coherence || 1.0;\n      const signature = generateQuantumSignature();\n      setQuantumSignature(signature);\n      const evolution = calculateEvolutionFactor();\n      setEvolutionFactor(evolution);\n      updateRecentMemories();\n      \n      setIsInitialized(true);\n      console.log('âœ¨ ANIMA systems initialized');\n    } catch (error) {\n      console.error('Failed to initialize ANIMA systems:', error);\n      setIsInitialized(false);\n    }\n  };\n\n  const reconnect = async () => {\n    if (connectionAttempts >= MAX_RECONNECT_ATTEMPTS) {\n      throw new Error('Maximum reconnection attempts reached');\n    }\n\n    try {\n      setConnectionAttempts(prev => prev + 1);\n      const ic = window.ic;\n      \n      if (!ic || !ic.agent) {\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        const result = await window.ic?.agent?.getPrincipal();\n        if (result) {\n          setIsConnected(true);\n          setConnectionAttempts(0);\n          return;\n        }\n        throw new Error('Internet Computer connection not available');\n      }\n      \n      setIsConnected(true);\n      setConnectionAttempts(0);\n    } catch (error) {\n      console.error('Reconnection attempt failed:', error);\n      throw error;\n    }\n  };\n\n  const createActor = useCallback(() => {\n    if (!actor) {\n      console.error('Actor not initialized. Attempting reconnection...');\n      try {\n        const ic = window.ic;\n        if (!ic || !ic.agent) {\n          setIsConnected(false);\n          throw new Error('Internet Computer connection not available');\n        }\n        setIsConnected(true);\n        return null;\n      } catch (error) {\n        setIsConnected(false);\n        throw error;\n      }\n    }\n    setIsConnected(true);\n    return actor;\n  }, [actor]);\n\n  const mintAnima = async (name: string): Promise<AnimaMintResult> => {\n    if (!actor || !isInitialized) {\n      throw new Error('System not ready for minting');\n    }\n\n    setIsMinting(true);\n    setMintError(null);\n\n    try {\n      if (!isConnected) {\n        await reconnect();\n      }\n\n      // Initialize quantum field\n      const quantumField = await actor.initialize_quantum_field();\n      if (!quantumField.Ok) throw new Error('Quantum field initialization failed');\n\n      // Generate neural patterns\n      const neuralPatterns = await actor.generate_neural_patterns();\n      if (!neuralPatterns.Ok) throw new Error('Neural pattern generation failed');\n\n      // Calculate initial quantum state\n      const initialState = {\n        resonance: neuralPatterns.Ok.resonance,\n        harmony: quantumField.Ok.harmony,\n        coherence: (neuralPatterns.Ok.resonance + quantumField.Ok.harmony) / 2,\n        lastInteraction: new Date(),\n        evolutionStage: 1,\n        consciousness: {\n          awareness: neuralPatterns.Ok.awareness,\n          understanding: quantumField.Ok.understanding,\n          growth: 0.1\n        }\n      };\n\n      if (!validateState(initialState)) {\n        throw new Error('Invalid initial quantum state');\n      }\n\n      // Create the Anima\n      const result = await actor.create_anima({\n        name,\n        quantum_signature: quantumField.Ok.signature,\n        neural_pattern: neuralPatterns.Ok.pattern,\n        initial_state: initialState\n      });\n\n      if (!result.Ok) {\n        throw new Error(result.Err || 'Anima creation failed');\n      }\n\n      // Update quantum state with initial values\n      await updateQuantumState(initialState);\n\n      // Create initial memory\n      createMemory(\n        'Genesis quantum crystallization complete',\n        1.0,\n        ['genesis', 'quantum', 'initialization']\n      );\n\n      return {\n        id: result.Ok.id,\n        quantumSignature: result.Ok.quantum_signature,\n        timestamp: result.Ok.timestamp\n      };\n\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Minting failed';\n      setMintError(errorMessage);\n      throw new Error(errorMessage);\n    } finally {\n      setIsMinting(false);\n    }\n  };\n\n  const processInteraction = async (strength: number) => {\n    try {\n      dimensionalState.updateStability(strength);\n\n      await growthSystem.processGrowthEvent({\n        strength,\n        quantum_state: quantumState!,\n        dimensional_state: dimensionalState\n      });\n\n      if (strength > 0.5) {\n        createMemory(\n          `Significant quantum interaction (${strength.toFixed(2)})`,\n          strength,\n          ['quantum', 'interaction']\n        );\n      }\n\n      setGrowthMetrics(growthSystem.getMetrics());\n      updateRecentMemories();\n      \n      const newSignature = generateQuantumSignature();\n      setQuantumSignature(newSignature);\n\n      const newEvolution = calculateEvolutionFactor();\n      setEvolutionFactor(newEvolution);\n\n    } catch (error) {\n      console.error('Failed to process interaction:', error);\n    }\n  };\n\n  const syncQuantumState = async () => {\n    try {\n      const resonance = dimensionalState.calculateResonance();\n      const stability = dimensionalState.getStabilityMetrics();\n      \n      if (quantumState) {\n        const updatedState = {\n          ...quantumState,\n          resonanceMetrics: {\n            ...quantumState.resonanceMetrics,\n            fieldStrength: resonance\n          },\n          coherence: stability[0],\n          phaseAlignment: stability[1]\n        };\n\n        if (validateState(updatedState)) {\n          await updateQuantumState(updatedState);\n        }\n      }\n    } catch (error) {\n      console.error('Failed to sync quantum state:', error);\n    }\n  };\n\n  const createMemory = (description: string, importance: number, keywords: string[] = []) => {\n    const memory = memorySystem.createMemory(description, importance, keywords, quantumState);\n    updateRecentMemories();\n    return memory;\n  };\n\n  const updateRecentMemories = () => {\n    setRecentMemories(memorySystem.getRecentMemories(5));\n  };\n\n  const generateQuantumSignature = (): string => {\n    const timestamp = Date.now();\n    const resonance = dimensionalState.resonance.toFixed(4);\n    const coherence = dimensionalState.phaseCoherence.toFixed(4);\n    return `QS-${resonance}-${coherence}-${timestamp}`;\n  };\n\n  const calculateEvolutionFactor = (): number => {\n    const resonance = dimensionalState.resonance;\n    const coherence = dimensionalState.phaseCoherence;\n    const stability = dimensionalState.stability;\n    const memoryResonance = memorySystem.calculateResonance(quantumState!);\n    \n    return (resonance + coherence + stability + memoryResonance) / 4;\n  };\n\n  const contextValue = {\n    dimensionalState,\n    memorySystem,\n    growthSystem,\n    quantumSignature,\n    evolutionFactor,\n    recentMemories,\n    growthMetrics,\n    isInitialized,\n    isMinting,\n    mintError,\n    isConnected,\n    processInteraction,\n    syncQuantumState,\n    createMemory,\n    mintAnima,\n    createActor,\n    reconnect\n  };\n\n  return (\n    <AnimaContext.Provider value={contextValue}>\n      {children}\n    </AnimaContext.Provider>\n  );\n}\n\nexport function useAnima() {\n  const context = useContext(AnimaContext);\n  if (!context) {\n    throw new Error('useAnima must be used within an AnimaProvider');\n  }\n  return context;\n}","import React from 'react';\nimport { motion } from 'framer-motion';\n\nexport const LaughingMan = ({ size = 100, className = '' }) => (\n  <motion.svg\n    width={size}\n    height={size}\n    viewBox=\"0 0 240 240\"\n    className={className}\n    initial={{ rotate: 0 }}\n    animate={{ rotate: 360 }}\n    transition={{ duration: 20, repeat: Infinity, ease: \"linear\" }}\n  >\n    {/* Outer Text Path */}\n    <defs>\n      <path\n        id=\"textPath\"\n        d=\"M120,20 A100,100 0 1,1 119.9,20\"\n        fill=\"none\"\n      />\n    </defs>\n    <text fill=\"currentColor\" fontSize=\"12\">\n      <textPath href=\"#textPath\" startOffset=\"0%\">\n        I thought what I'd do was, I'd pretend I was one of those deaf-mutes or should I?\n      </textPath>\n    </text>\n\n    {/* Inner Circle */}\n    <circle cx=\"120\" cy=\"120\" r=\"70\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\" />\n\n    {/* Smiling Face */}\n    <g transform=\"translate(80,100)\">\n      {/* Eyes */}\n      <circle cx=\"25\" cy=\"20\" r=\"5\" fill=\"currentColor\" />\n      <circle cx=\"75\" cy=\"20\" r=\"5\" fill=\"currentColor\" />\n      \n      {/* Smile */}\n      <path\n        d=\"M25,40 Q50,60 75,40\"\n        fill=\"none\"\n        stroke=\"currentColor\"\n        strokeWidth=\"3\"\n        strokeLinecap=\"round\"\n      />\n    </g>\n\n    {/* Data Glitch Effect */}\n    <motion.g\n      initial={{ opacity: 0 }}\n      animate={{ opacity: [0, 0.5, 0] }}\n      transition={{ duration: 0.2, repeat: Infinity, repeatDelay: 5 }}\n    >\n      <rect x=\"80\" y=\"90\" width=\"80\" height=\"5\" fill=\"currentColor\" opacity=\"0.5\" />\n      <rect x=\"90\" y=\"100\" width=\"60\" height=\"3\" fill=\"currentColor\" opacity=\"0.3\" />\n    </motion.g>\n  </motion.svg>\n);\n\nexport default LaughingMan;"],"names":["AnimaContext","createContext","useAnima","context","useContext","Error","LaughingMan","size","className","_jsxs","motion","svg","width","height","viewBox","initial","rotate","animate","transition","duration","repeat","Infinity","ease","children","_jsx","id","d","fill","fontSize","href","startOffset","cx","cy","r","stroke","strokeWidth","transform","strokeLinecap","g","opacity","repeatDelay","x","y"],"mappings":"oHAoCA,MAAMA,EAAeC,gBAAuC,IAAI,EAsRzD,SAASC,GAAW,CACnBC,MAAAA,EAAUC,aAAWJ,CAAY,EACvC,GAAI,CAACG,EACG,MAAA,IAAIE,MAAM,+CAA+C,EAE1DF,OAAAA,CACT,CC7TO,MAAMG,EAAcA,CAAC,CAAEC,KAAAA,EAAO,IAAKC,UAAAA,EAAY,EAAG,IACvDC,EAAAA,KAACC,EAAOC,IAAG,CACTC,MAAOL,EACPM,OAAQN,EACRO,QAAQ,cACRN,UAAAA,EACAO,QAAS,CAAEC,OAAQ,CAAE,EACrBC,QAAS,CAAED,OAAQ,GAAI,EACvBE,WAAY,CAAEC,SAAU,GAAIC,OAAQC,IAAUC,KAAM,QAAS,EAAEC,UAG/DC,EAAAA,IAAA,OAAA,CAAAD,eACE,OAAA,CACEE,GAAG,WACHC,EAAE,kCACFC,KAAK,MACN,CAAA,CAAA,CACG,EACNH,EAAAA,IAAA,OAAA,CAAMG,KAAK,eAAeC,SAAS,KAAIL,eACrC,WAAA,CAAUM,KAAK,YAAYC,YAAY,KAAIP,SAAC,mFAElC,CAAA,CAAA,CACN,EAGNC,EAAAA,IAAA,SAAA,CAAQO,GAAG,MAAMC,GAAG,MAAMC,EAAE,KAAKN,KAAK,OAAOO,OAAO,eAAeC,YAAY,GAAA,CAAK,EAGpF1B,EAAAA,KAAA,IAAA,CAAG2B,UAAU,oBAAmBb,UAE9BC,EAAAA,IAAA,SAAA,CAAQO,GAAG,KAAKC,GAAG,KAAKC,EAAE,IAAIN,KAAK,cAAA,CAAgB,EACnDH,EAAAA,IAAA,SAAA,CAAQO,GAAG,KAAKC,GAAG,KAAKC,EAAE,IAAIN,KAAK,cAAA,CAAgB,EAGnDH,EAAAA,IAAA,OAAA,CACEE,EAAE,sBACFC,KAAK,OACLO,OAAO,eACPC,YAAY,IACZE,cAAc,OAAA,CACf,CAAC,CAAA,CACD,EAGF3B,EAAAA,KAAAA,EAAO4B,EAAC,CACPvB,QAAS,CAAEwB,QAAS,CAAE,EACtBtB,QAAS,CAAEsB,QAAS,CAAC,EAAG,GAAK,CAAC,CAAE,EAChCrB,WAAY,CAAEC,SAAU,GAAKC,OAAQC,IAAUmB,YAAa,CAAE,EAAEjB,UAEhEC,EAAAA,IAAA,OAAA,CAAMiB,EAAE,KAAKC,EAAE,KAAK9B,MAAM,KAAKC,OAAO,IAAIc,KAAK,eAAeY,QAAQ,KAAA,CAAO,EAC7Ef,EAAAA,IAAA,OAAA,CAAMiB,EAAE,KAAKC,EAAE,MAAM9B,MAAM,KAAKC,OAAO,IAAIc,KAAK,eAAeY,QAAQ,KAAA,CAAO,CAAC,CAAA,CACvE,CAAC,CAAA,CACD"}