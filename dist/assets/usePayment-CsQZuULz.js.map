{"version":3,"file":"usePayment-CsQZuULz.js","sources":["../../src/hooks/usePayment.ts"],"sourcesContent":["import { useState, useCallback } from 'react';\nimport { useAuth } from '@/contexts/auth-context';\nimport { useQuantumState } from '@/hooks/useQuantumState';\nimport { Principal } from '@dfinity/principal';\nimport { PaymentResult, PaymentVerification, PaymentParams, TransactionReceipt, QuantumSignedReceipt } from '../types/payment';\nimport { ErrorTracker } from '../error/quantum_error';\n\nconst PAYMENT_AMOUNTS = {\n  Genesis: BigInt(100_000_000), // 1 ICP\n  Evolution: BigInt(50_000_000), // 0.5 ICP\n  Feature: BigInt(25_000_000),  // 0.25 ICP\n  Quantum: BigInt(75_000_000),  // 0.75 ICP\n};\n\nconst VERIFICATION_RETRIES = 3;\nconst VERIFICATION_INTERVAL = 2000;\nconst BALANCE_BUFFER = BigInt(10_000_000); // 0.1 ICP safety buffer\n\nexport const usePayment = () => {\n  const { actor, principal } = useAuth();\n  const { quantumState, updateQuantumState } = useQuantumState();\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [lastTransaction, setLastTransaction] = useState<PaymentResult | null>(null);\n  const [transactionReceipts] = useState<Map<string, TransactionReceipt>>(new Map());\n\n  const generateQuantumSignature = useCallback(async (transaction: PaymentResult): Promise<QuantumSignedReceipt> => {\n    if (!quantumState) throw new Error('Quantum state not initialized');\n\n    const quantumSignature = {\n      resonance: quantumState.resonance,\n      coherence: quantumState.coherenceLevel,\n      timestamp: Date.now(),\n      transactionHash: `${transaction.height}-${Date.now()}-${Math.random()}`\n    };\n\n    return {\n      ...transaction,\n      quantum: quantumSignature,\n      verified: true,\n      timestamp: BigInt(Date.now())\n    };\n  }, [quantumState]);\n\n  const validateBalance = useCallback(async (amount: bigint): Promise<boolean> => {\n    try {\n      const balance = await getBalance();\n      const requiredAmount = amount + BALANCE_BUFFER;\n      \n      if (balance < requiredAmount) {\n        throw new Error(`Insufficient balance. Need ${Number(requiredAmount) / 100_000_000} ICP (including buffer)`);\n      }\n\n      const stateValid = await validateQuantumState();\n      if (!stateValid) {\n        throw new Error('Quantum state unstable for transaction');\n      }\n\n      return true;\n    } catch (error) {\n      throw error;\n    }\n  }, []);\n\n  const validateQuantumState = useCallback(async (): Promise<boolean> => {\n    if (!quantumState) return false;\n    \n    const minCoherence = 0.7;\n    const minResonance = 0.6;\n\n    return quantumState.coherenceLevel >= minCoherence && \n           quantumState.resonance >= minResonance;\n  }, [quantumState]);\n\n  const getBalance = useCallback(async (): Promise<bigint> => {\n    if (!actor || !principal) {\n      throw new Error('Not authenticated');\n    }\n\n    try {\n      const balance = await actor.icrc1_balance_of({\n        owner: Principal.fromText(principal),\n        subaccount: [],\n      });\n      return balance;\n    } catch (err) {\n      console.error('Balance check failed:', err);\n      throw new Error('Failed to fetch balance');\n    }\n  }, [actor, principal]);\n\n  const initiatePayment = useCallback(async ({\n    amount,\n    memo = BigInt(Date.now()),\n    toCanister\n  }: PaymentParams): Promise<PaymentResult> => {\n    if (!actor || !principal) {\n      throw new Error('Not authenticated');\n    }\n\n    setIsProcessing(true);\n    setError(null);\n\n    try {\n      await validateBalance(amount);\n\n      const result = await actor.icrc2_transfer({\n        amount,\n        to: { owner: toCanister, subaccount: [] },\n        fee: [],\n        memo: [memo],\n        from_subaccount: [],\n        created_at_time: [BigInt(Date.now())],\n      });\n\n      if ('Err' in result) {\n        throw new Error(JSON.stringify(result.Err));\n      }\n\n      const payment: PaymentResult = {\n        height: result.Ok,\n        transactionId: result.Ok.toString(),\n      };\n\n      const signedReceipt = await generateQuantumSignature(payment);\n      transactionReceipts.set(payment.transactionId, signedReceipt);\n\n      setLastTransaction(payment);\n      return payment;\n\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Payment failed';\n      setError(errorMessage);\n      ErrorTracker.getInstance().trackError({\n        type: 'PAYMENT_ERROR',\n        message: errorMessage,\n        timestamp: Date.now(),\n        quantum: quantumState\n      });\n      throw new Error(errorMessage);\n    } finally {\n      setIsProcessing(false);\n    }\n  }, [actor, principal, validateBalance, generateQuantumSignature, quantumState]);\n\n  const verifyPayment = useCallback(async (height: bigint): Promise<PaymentVerification> => {\n    if (!actor) {\n      throw new Error('Not authenticated');\n    }\n\n    let retries = VERIFICATION_RETRIES;\n    \n    while (retries > 0) {\n      try {\n        const result = await actor.verify_payment(height);\n        \n        if ('Ok' in result) {\n          const quantumSignedResult = await generateQuantumSignature({\n            height,\n            transactionId: height.toString()\n          });\n\n          const verificationResult: PaymentVerification = {\n            verified: true,\n            timestamp: result.Ok.timestamp,\n            status: 'confirmed',\n            quantumSignature: quantumSignedResult.quantum\n          };\n\n          return verificationResult;\n        }\n\n        if (retries === 1) {\n          return {\n            verified: false,\n            timestamp: BigInt(Date.now()),\n            status: 'failed',\n            quantumSignature: null\n          };\n        }\n\n        await new Promise(resolve => setTimeout(resolve, VERIFICATION_INTERVAL));\n        retries--;\n        \n      } catch (err) {\n        if (retries === 1) {\n          throw new Error('Payment verification failed');\n        }\n        await new Promise(resolve => setTimeout(resolve, VERIFICATION_INTERVAL));\n        retries--;\n      }\n    }\n\n    return {\n      verified: false,\n      timestamp: BigInt(Date.now()),\n      status: 'failed',\n      quantumSignature: null\n    };\n  }, [actor, generateQuantumSignature]);\n\n  const getTransactionReceipt = useCallback((transactionId: string): TransactionReceipt | undefined => {\n    return transactionReceipts.get(transactionId);\n  }, [transactionReceipts]);\n\n  const getPaymentAmount = useCallback((type: keyof typeof PAYMENT_AMOUNTS) => {\n    return PAYMENT_AMOUNTS[type];\n  }, []);\n\n  const getTransactionStatus = useCallback(async (transactionId: string) => {\n    if (!actor) {\n      throw new Error('Not authenticated');\n    }\n\n    try {\n      const status = await actor.get_transaction_status(transactionId);\n      const receipt = transactionReceipts.get(transactionId);\n      \n      return {\n        ...status,\n        receipt,\n        quantumVerified: receipt?.quantum ? true : false\n      };\n    } catch (err) {\n      console.error('Failed to get transaction status:', err);\n      throw new Error('Transaction status check failed');\n    }\n  }, [actor]);\n\n  return {\n    initiatePayment,\n    verifyPayment,\n    getBalance,\n    getPaymentAmount,\n    getTransactionStatus,\n    getTransactionReceipt,\n    isProcessing,\n    error,\n    lastTransaction,\n  };\n};\n\nexport type PaymentHook = ReturnType<typeof usePayment>;"],"names":["PAYMENT_AMOUNTS","Genesis","BigInt","Evolution","Feature","Quantum","VERIFICATION_RETRIES","VERIFICATION_INTERVAL","BALANCE_BUFFER","usePayment","actor","principal","useAuth","quantumState","updateQuantumState","useQuantumState","isProcessing","setIsProcessing","useState","error","setError","lastTransaction","setLastTransaction","transactionReceipts","Map","generateQuantumSignature","useCallback","transaction","Error","quantumSignature","resonance","coherence","coherenceLevel","timestamp","Date","now","transactionHash","height","Math","random","quantum","verified","validateBalance","amount","balance","getBalance","requiredAmount","Number","validateQuantumState","icrc1_balance_of","owner","Principal","fromText","subaccount","err","initiatePayment","memo","toCanister","result","icrc2_transfer","to","fee","from_subaccount","created_at_time","JSON","stringify","Err","payment","Ok","transactionId","toString","signedReceipt","set","errorMessage","message","getInstance","trackError","type","verifyPayment","retries","verify_payment","quantumSignedResult","verificationResult","status","Promise","resolve","setTimeout","getTransactionReceipt","get","getPaymentAmount","getTransactionStatus","get_transaction_status","receipt","quantumVerified"],"mappings":"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"}